#!/bin/bash

##############################################################################
# Distributed Package Manager
# https://github.com/markuskimius/dpm
#
# Copyright (c)2021 Mark K. Kim
# Released under GNU General Public License version 2.
# https://github.com/markuskimius/dpm/blob/main/LICENSE
##############################################################################

function usage() {
    cat <<EOF
Usage: ${SCRIPTNAME} COMMAND [ARGUMENTS]

COMMAND:
  install [-b,--branch=BRANCH] URL [PKGNAME]
                        Install PKGNAME from URL and its dependencies, if any.
                        If PKGNAME is omitted a name is chosen based on the
                        URL.

  mv PKGNAME1 PKGNAME2  Rename PKGNAME1 to PKGNAME2 if possible.

  remove PKGNAME        Remove PKGNAME and any of its unused dependencies.

  update [PKGNAME]      Update PKGNAME, installing any new dependency.  Any
                        stale dependency is not removed.  Use '${SCRIPTNAME}
                        cleanup' to remove any stale dependency that is no
                        longer required.  If PKGNAME is omitted all packages
                        are updated.

  recover               Rebuild the file that tracks installed packages and
                        their dependencies.  Any missing dependency is
                        installed but stale dependency is not removed; use
                        '${SCRIPTNAME} cleanup' to remove any stale dependency
                        that is no longer required.

  cleanup               Delete any package installed as a dependency but is no
                        longer required.

  list [-l,--long]      List installed packages.

  sourceme              Source this output to setup BASH.

  sourceit PKGNAME      Source this output to setup BASH for PKGNAME.

FILES:
  Config files:$(printf "\n    %s" "${CONFIGS[@]}")

EOF
}


##############################################################################
# PROGRAM BEGINS HERE

SCRIPTNAME=$(basename -- "$0")
SCRIPTPATH=$0
SCRIPTARGV=( "$@" )
PKGDIR=${HOME}/dpm
HANDLERS=( git )
CONFIGS=(
    ~/.dpmrc
    /usr/local/etc/dpmrc
    /usr/etc/dpmrc
    /etc/dpmrc
)


function main() {
    local action=( usage )
    local lock=0
    local isok=1

    #
    # Initialize.  Note that lock-pkgdir may restart the script so any code
    # that runs before it must be idempotent.
    #
    # load-config and ensure-deps must run before lock-pkgdir because
    # lock-pkgdir depends on them.
    #
    load-config || exit 1
    ensure-deps || exit 1

    # Check arguments
    case "${1-}" in
        install)      shift && action=( dpm-install -dr  ) && lock=1 ;;
        mv)           shift && action=( dpm-rename       ) && lock=1 ;;
        remove)       shift && action=( dpm-remove -dr   ) && lock=1 ;;
        update)       shift && action=( dpm-update       ) && lock=1 ;;
        recover)      shift && action=( dpm-recover      ) && lock=1 ;;
        cleanup)      shift && action=( dpm-cleanup      ) && lock=1 ;;
        list)         shift && action=( dpm-list         ) && lock=1 ;;
        sourceme)     shift && action=( dpm-sourceme     ) ;;
        sourceit)     shift && action=( dpm-sourceit     ) && lock=1 ;;
        help)         shift && action=( usage            ) ;;
        *)            logger FAIL "${1-(none)}: Invalid COMMAND"
                      isok=0
                      ;;
    esac

    # Sanity check
    if (( ! isok )); then
        usage 1>&2
        exit 1
    fi

    # Lock
    if (( lock )); then
        lock-pkgdir || exit 1
    fi

    "${action[@]}" "$@"
}


function load-config() {
    local isok=1
    local file

    # Defaults
    set -o pipefail

    # Clear globals
    LOGGER_INDENT=0
    INSTALLED=

    # Source the first file found in CONFIG[], if any
    for file in "${CONFIGS[@]}"; do
        if [[ -e "$file" ]]; then
            source "$file" || isok=0
            break
        fi
    done

    (( isok ))
}


function ensure-deps() {
    local handler
    local isok=1

    # Check for awk
    if ! command -v awk >/dev/null; then
        logger FAIL "Please install awk."
        isok=0
    fi

    # Check for flock or shlock
    if ! command -v flock >/dev/null && ! command -v shlock >/dev/null; then
        logger FAIL "Please install flock or shlock."
        isok=0
    fi

    # Check for handler dependencies
    for handler in "${HANDLERS[@]}"; do
        local depfn="${handler}-testdeps"

        if ! command -v "$depfn" >/dev/null; then
            logger FAIL "${handler}: Bad handler" && isok=0
            continue
        fi

        "$depfn" || isok=0
    done

    # Ensure $PKGDIR exists
    if [[ ! -d "$PKGDIR" ]] && ! mkdir -p "$PKGDIR" 2>/dev/null; then
        logger FAIL "Unable to create $PKGDIR"
        isok=0
    fi

    # Ensure the installed file exists
    if [[ ! -w "${PKGDIR}/.installed" ]] && ! touch "${PKGDIR}/.installed" 2>/dev/null; then
        logger FAIL "Unable to create ${PKGDIR}/.installed"
        isok=0
    fi

    (( isok ))
}


function lock-pkgdir() {
    local lockfile="${PKGDIR}/.lock"
    local locked=0

    #
    # 'flock' is preferred but (1) it requires restarting the script and (2) it
    # may not be available on some systems.  This script must be written such
    # that (1) is not an issue.
    #
    # As for (2), we fall back on 'shlock' if 'flock' is not available.
    # 'shlock' is less preferred because it may run into a race condition on
    # some platforms.  Also, as with 'flock', it may not be available on some
    # systems.
    #

    if command -v flock >/dev/null; then
        if [[ "$FLOCKER" == "$lockfile" ]]; then
            locked=1
        else
            export FLOCKER=$lockfile
            exec flock "$lockfile" "$SCRIPTPATH" "${SCRIPTARGV[@]}"
        fi
    elif command -v shlock >/dev/null; then
        while true; do
            shlock -p $$ -f "$lockfile" && locked=1 && break
            sleep 1
        done
    else
        logger FAIL "No locking command available"
    fi

    (( locked ))
}


##############################################################################
# ACTIONS

function dpm-install() {
    local optstring url pkgname handler
    local direct=0 safemode=0 recursive=0 trackback="" branch=""
    local unwind=0

    # Parse arguments
    optstring=$(egetopt "dsrt:b:" "direct,safemode,recursive,trackback:,branch:" "$@") || return 1
    eval set -- "$optstring"

    while (( $# )); do
        [[ "$1" == "--" ]] && shift && break

        case "$1" in
            -d|--direct)    direct=1              ;;
            -s|--safemode)  safemode=1            ;;
            -r|--recursive) recursive=1           ;;
            -t|--trackback) trackback=$2 && shift ;;
            -b|--branch)    branch=$2 && shift    ;;
        esac

        shift
    done

    # Optionless arguments
    url=$1
    pkgname=${2-}
    handler=$(url-gethandler "$url")

    if [[ -z "$pkgname" && -n "$handler" && -n "$url" ]]; then
        pkgname=$("${handler}-urlpkg" "$url")
    fi

    # Allow an already-installed package be marked as direct-installed by pkgname
    if [[ -z "$pkgname" ]] && pkg-isinstalled "$url" && (( direct )); then
        pkgname=$url
        url=$(pkg-geturl "$pkgname")
        branch=$(pkg-getbranch "$pkgname")
        handler=$(url-gethandler "$url")
    fi

    if [[ -z "$branch" ]]; then
        unset branch
    fi

    # Sanity check
    [[ -z "$url"     ]] && logger FAIL "Must specify URL." && return 1
    [[ -z "$pkgname" ]] && logger FAIL "Cannot deduce PKGNAME from URL '$url'" && return 1
    [[ -z "$handler" ]] && logger FAIL "${url}: Cannot identify handler for URL." && return 1

    # Notification
    logger INFO "INSTALL '${pkgname}' from ${url}${branch+ branch }${branch-} to ${PKGDIR}/${pkgname} ..."

    # Don't allow a package to be direct-installed more than once
    if pkg-isinstalled "$pkgname" && (( direct )) && [[ "$(instfile-getflags "$pkgname")" == *D* ]]; then
        logger INFO "${pkgname}: Already direct-installed."
        return 0
    fi

    # Don't allow circular dependency
    if [[ "|${trackback}|" == *"|${pkgname}|"* ]]; then
        logger FAIL "${pkgname}: FAILED to install, circular dependency."
        return 1
    fi

    # Install the package
    if pkg-isinstalled "$pkgname"; then
        local installed_url=$(pkg-geturl "$pkgname")
        local installed_branch=$(pkg-getbranch "$pkgname")

        if [[ "$url" == "$installed_url" && ( -z "${branch-}" || "${branch-}" == "$installed_branch" ) ]]; then
            logger INFO "${pkgname}: Already installed."
            REFDEPTH=$(instfile-refdepth "$pkgname")
        else
            logger FAIL "${pkgname}: Already installed but from ${installed_url} branch ${installed_branch}, cannot proceed."
            false
        fi
    else
        "${handler}-install" "$url" "$pkgname" "${branch-}" 2>&1 | logger "${handler}"
        REFDEPTH=0
    fi || unwind=10

    # Install the dependencies
    if (( ! unwind && recursive )); then
        local flags=( -t "${trackback}|${pkgname}" )

        if (( safemode )); then
            flags+=( -s )
        fi

        dpm-install-deps "${flags[@]}" "$pkgname"
        (( REFDEPTH += 1 ))
    fi || unwind=20

    # Add the installation record
    if (( ! unwind )); then
        local flags=( -d "$REFDEPTH" )

        if (( direct )); then
            flags+=( -fD )
        fi

        logger INFO "${pkgname}: Update installation record..."
        instfile-incr "${flags[@]}" "$pkgname"
    fi || unwind=30

    # Success!
    if (( ! unwind )); then
        logger GOOD "${pkgname}: INSTALL SUCCESS!"
        return 0
    fi

    # Notification
    logger FAIL "${pkgname}: FAILED to install."

    # Unwind the recording of how the package was installed
    if (( unwind > 20 )); then
        logger INFO "${pkgname}: Rollback dependencies..."
        dpm-remove-deps "$pkgname"
    fi

    # Unwind the installation
    if (( unwind >= 10 )) && (( $(instfile-refcount "$pkgname") <= 0 )) && (( ! safemode )); then
        #
        # Unlike above unwinding routines, this code is executed even if the
        # handler-install fails because handler-install may be a user-supplied
        # function that does not fully cleans up after itself.
        #
        logger INFO "${pkgname}: Rollback installed files..."
        [[ -n "$PKGDIR" && -n "$pkgname" ]] && "${handler}-remove" "$pkgname" 2>&1 | logger "${handler}"
    fi

    return 1
}


function dpm-install-deps() {
    local optstring pkgname
    local safemode=0 trackback=""
    local depname depurl depbranch deprest
    local installed=()
    local unwind=0
    local count=0

    # Parse arguments
    optstring=$(egetopt "st:" "safemode,trackback:" "$@") || return 1
    eval set -- "$optstring"

    while (( $# )); do
        [[ "$1" == "--" ]] && shift && break

        case "$1" in
            -s|--safemode)  safemode=1            ;;
            -t|--trackback) trackback=$2 && shift ;;
        esac

        shift
    done

    # Install the dependencies
    for pkgname in "$@"; do
        local flags=( -rt "${trackback}" )
        local depth=0

        if (( safemode )); then
            flags+=( -s )
        fi

        while IFS=\| read -r depname depurl depbranch deprest; do
            [[ -z "$depbranch" ]] && unset depbranch
            logger INFO "${pkgname}: Requires '${depname}' from ${depurl}${depbranch+ branch }${depbranch-}:"

            logger-push
            dpm-install "${flags[@]}" -b "${depbranch-}" "$depurl" "$depname" \
            && installed=( "$depname" ) \
            && depth=$(( REFDEPTH > depth ? REFDEPTH : depth )) \
            || unwind=10
            logger-pop

            # Stop on error
            (( unwind )) && break
            (( count += 1 ))
        done < <(pkg-getdeps "$pkgname")

        REFDEPTH=$depth
    done

    # Success!
    if (( ! unwind )); then
        return 0
    fi

    # Unwind the installed packages
    if (( unwind > 0 && count )); then
        local flags=( -r )

        if (( safemode )); then
            flags+=( -s )
        fi

        # Notification
        logger FAIL "${pkgname}: FAILED to install a dependency, remove already installed dependencies..."

        logger-push
        for depname in "${installed[@]}"; do
            dpm-remove "${flags[@]}" "$depname"
        done
        logger-pop
    fi

    return 1
}


function dpm-rename() {
    local pkgname1=$1
    local pkgname2=$2
    local flags depth
    local unwind=0

    # Sanity check
    [[ -z "$pkgname1" || -z "$pkgname2" ]] && logger FAIL "Must specify PKGNAME1 and PKGNAME2." && return 1

    # Notification
    logger INFO "RENAME '${pkgname1}' to '${pkgname2}'..."

    # PKGNAME1 must exist
    if ! pkg-isinstalled "$pkgname1"; then
        logger ERROR "${pkgname1}: No such package."
        return 1
    fi

    # Get the flags for PKGNAME1
    flags=$(instfile-getflags "$pkgname1")
    depth=$(instfile-refdepth "$pkgname1")

    # PKGNAME1 must be direct installed and must have no other dependency
    if [[ "$flags" != *D* ]] || (( $(instfile-refcount "$pkgname1") != 1 )); then
        logger ERROR "${pkgname1}: Cannot be renamed, has dependencies."
        return 1
    fi

    # PKGNAME2 must not exist
    if pkg-isinstalled "$pkgname2"; then
        logger ERROR "${pkgname2}: Already exists."
        return 1
    fi

    # Rename
    if (( ! unwind )); then
        logger INFO "${pkgname1}: Rename package directory..."
        mv "${PKGDIR}/${pkgname1}" "${PKGDIR}/${pkgname2}"
    fi || unwind=10

    # Update the installation record
    if (( ! unwind )); then
        logger INFO "${pkgname2}: Increment installation record..."

        instfile-incr -f "$flags" -d "$depth" "$pkgname2"
    fi || unwind=20

    if (( ! unwind )); then
        logger INFO "${pkgname1}: Decrement installation record..."

        instfile-decr -f "$flags" "$pkgname1"
    fi || unwind=30

    # Success!
    if (( ! unwind )); then
        logger GOOD "${pkgname2}: RENAME SUCCESS!"
        return 0
    fi

    # Notification
    logger FAIL "${pkgname1}: FAILED to rename."

    # Unwind the incrementing of the installation record
    if (( unwind > 20 )); then
        logger INFO "${pkgname2}: Rollback installation record..."
        instfile-decr -f "$flags" "$pkgname2"
    fi

    # Unwind the renaming of the directory
    if (( unwind > 10 )); then
        logger INFO "${pkgname2}: Rollback renaming of the package directory..."
        mv "${PKGDIR}/${pkgname2}" "${PKGDIR}/${pkgname1}"
    fi

    return 1
}


function dpm-remove() {
    local optstring pkgname
    local direct=0 safemode=0 recursive=0 trackback=""
    local isok=1

    # Parse arguments
    optstring=$(egetopt "dsrt:" "direct,safemode,recursive,trackback:" "$@") || return 1
    eval set -- "$optstring"

    while (( $# )); do
        [[ "$1" == "--" ]] && shift && break

        case "$1" in
            -d|--direct)    direct=1              ;;
            -s|--safemode)  safemode=1            ;;
            -r|--recursive) recursive=1           ;;
            -t|--trackback) trackback=$2 && shift ;;
        esac

        shift
    done

    # Sanity check
    (( ! $# )) && logger FAIL "Must specify at least one PKGNAME" && return 1

    # Remove the package(s)
    for pkgname in "$@"; do
        local removeok=1

        # Notification
        logger INFO "REMOVE '${pkgname}'..."

        # Sanity check
        if ! pkg-isinstalled "$pkgname"; then
            logger WARN "${pkgname}: No such package, nothing to remove."
            continue
        fi

        # Don't allow a package to be direct-removed if it wasn't direct-installed
        if (( direct )) && [[ "$(instfile-getflags "$pkgname")" != *D* ]]; then
            logger FAIL "${pkgname}: Not direct-installed, cannot be direct-removed."
            isok=0
            continue
        fi

        # Don't allow a direct-installed package to be removed by a dependency-removal
        if (( ! direct )) && (( $(instfile-refcount "$pkgname") == 1 )) && [[ "$(instfile-getflags "$pkgname")" == *D* ]]; then
            logger FAIL "${pkgname}: Not installed as a dependency, cannot be direct-removed."
            isok=0
            continue
        fi

        # Don't allow circular dependency
        if [[ "|${trackback}|" == *"|${pkgname}|"* ]]; then
            logger FAIL "${pkgname}: FAILED to remove, circular dependency."
            isok=0
            continue
        fi

        # Remove the dependencies
        if (( recursive )); then
            local flags=( -t "${trackback}|${pkgname}" )

            if (( safemode )); then
                flags+=( -s )
            fi

            dpm-remove-deps "${flags[@]}" "$pkgname" \
            || removeok=0

            (( ! removeok )) && isok=0 && continue
        fi

        # Remove the installation record
        if true; then
            local flags=()

            if (( direct )); then
                flags+=( -fD )
            fi

            logger INFO "${pkgname}: Remove installation record..."
            instfile-decr "${flags[@]}" "$pkgname" \
            || removeok=0

            (( ! removeok )) && isok=0 && continue
        fi

        # Uninstall the package if needed
        if (( $(instfile-refcount "$pkgname") <= 0 )) && (( ! safemode )); then
            local url=$(pkg-geturl "$pkgname")
            local branch=$(pkg-getbranch "$pkgname")
            local handler=$(pkg-gethandler "$pkgname")

            logger INFO "${pkgname}: Remove files installed from ${url} branch ${branch} ..."

            if [[ -n "$handler" ]]; then
                [[ -n "$PKGDIR" && -n "$pkgname" ]] && "${handler}-remove" "$pkgname" 2>&1 | logger "${handler}"
            else
                logger FAIL "${pkgname}: Cannot identify handler."
                false
            fi || removeok=0

            (( ! removeok )) && isok=0 && continue
        fi
    done

    # Success!
    if (( isok )); then
        logger GOOD "${pkgname}: REMOVE SUCCESS!"
        return 0
    fi

    # Notification
    logger FAIL "${pkgname}: FAILED to remove completely, some record or files may remain."

    return 1
}


function dpm-remove-deps() {
    local optstring pkgname
    local safemode=0 trackback=""
    local depname depurl depbranch deprest
    local count=0
    local isok=1

    # Parse arguments
    optstring=$(egetopt "st:" "safemode,trackback:" "$@") || return 1
    eval set -- "$optstring"

    while (( $# )); do
        [[ "$1" == "--" ]] && shift && break

        case "$1" in
            -s|--safemode)  safemode=1            ;;
            -t|--trackback) trackback=$2 && shift ;;
        esac

        shift
    done

    # Remove the dependencies
    for pkgname in "$@"; do
        local flags=( -rt "${trackback}" )

        if (( safemode )); then
            flags+=( -s )
        fi

        while IFS=\| read -r depname depurl depbranch deprest; do
            logger INFO "${pkgname}: Depends on ${depname}:"

            logger-push
            dpm-remove "${flags[@]}" "$depname" \
            || isok=0
            logger-pop

            (( count += 1 ))
        done < <(pkg-getdeps "$pkgname")
    done

    (( isok ))
}


function dpm-update() {
    local pkgname
    local isok=1

    # Update all packages if no package specified
    if (( ! $# )); then
        local packages=()
        local line

        while IFS= read -r line; do
            packages+=( "$line" )
        done < <(installed-list)

        set -- "${packages[@]}"
    fi

    # Sanity check
    for pkgname in "$@"; do
        if ! pkg-isinstalled "$pkgname"; then
            logger FAIL "${pkgname}: No such package, nothing to update."
            isok=0
        fi
    done

    # Update the packages
    for pkgname in "$@"; do
        local handler predeps=() postdeps=()
        local updateok=1
        local line

        # Skip packages that have been removed (or never existed and logged already)
        pkg-isinstalled "$pkgname" || continue

        # Notification
        logger INFO "UPDATE '${pkgname}'..."

        handler=$(pkg-gethandler "$pkgname")
        if [[ -z "$handler" ]]; then
            logger FAIL "${pkgname}: Cannot identify handler."
            isok=0
            continue
        fi

        # Get the list of dependencies before update
        while IFS= read -r line; do
            predeps+=( "$line" )
        done < <(pkg-getdeps "$pkgname")

        # Update the package
        "${handler}-update" "$pkgname" 2>&1 | logger "${handler}" \
        || updateok=0

        # Get the list of dependencies after update
        while IFS= read -r line; do
            postdeps+=( "$line" )
        done < <(pkg-getdeps "$pkgname")

        # Install new dependencies
        if (( updateok )); then
            for line in "${postdeps[@]}"; do
                if [[ " ${predeps[@]} " != *" $line "* ]]; then
                    local depurl depname depbranch deprest
                    IFS=\| read -r depname depurl depbranch deprest <<<"$line"

                    logger INFO "${pkgname}: Now requires '${depname}' from ${depurl} branch ${depbranch}:"

                    logger-push
                    dpm-install -rt "$pkgname" -b "$depbranch" "$depurl" "$depname" \
                    || updateok=0
                    logger-pop
                fi

                (( ! updateok )) && break
            done
        fi

        # Remove stale dependencies
        if (( updateok )); then
            for line in "${predeps[@]}"; do
                if [[ " ${postdeps[@]} " != *" $line "* ]]; then
                    local depurl depname depbranch deprest
                    IFS=\| read -r depname depurl depbranch deprest <<<"$line"

                    logger INFO "${pkgname}: No longer requires '${depname}':"

                    logger-push
                    dpm-remove -srt "$pkgname" "$depname" \
                    || updateok=0
                    logger-pop
                fi
            done
        fi

        if (( updateok )); then
            logger GOOD "${pkgname}: UPDATE SUCCESS!"
        else
            logger FAIL "${pkgname}: FAILED to update."
            isok=0
        fi
    done

    (( isok ))
}


function dpm-recover() {
    local instfile="${PKGDIR}/.installed"
    local bkupfile="${instfile}.bkup"
    local dinstall=()
    local pkgname
    local isok=1

    # Notification
    logger INFO "RECOVER all packages..."

    # Get the list of direct-installed packages
    while IFS= read -r pkgname; do
        if [[ "$(instfile-getflags "$pkgname")" == *D* ]]; then
            dinstall+=( "$pkgname" )
        fi
    done < <(installed-list) || isok=0

    # Backup the installation file
    if (( isok )); then
        # Notification
        logger INFO "Backup the installation record..."

        rm -f "$bkupfile" \
        && mv "$instfile" "$bkupfile" \
        && touch "$instfile" \
        && INSTALLED="" \
        || isok=0
    fi

    # Re-install the direct-installed packages
    if (( isok )); then
        # Notification
        logger INFO "Reinstall direct-installed packages..."
        logger-push

        for pkgname in "${dinstall[@]}"; do
            dpm-install -dsr "$pkgname" || isok=0
        done

        logger-pop
    fi

    # Remove the backup installation file
    if (( isok )); then
        logger INFO "Remove the backup installation record..."
        rm -f "$bkupfile"

        logger GOOD "RECOVER SUCCESS!"
        return 0
    fi

    # Notification
    logger FAIL "${pkgname}: FAILED to recover, backup installation record at '${bkupfile}'"

    return 1
}


function dpm-cleanup() {
    local pkgname
    local isok=1

    # Notification
    logger INFO "CLEANUP..."

    # Get the list of packages to remove
    while IFS= read -r pkgname; do
        if (( $(instfile-refcount "$pkgname") == 0 )); then
            local instflags=$(instfile-getflags "$pkgname")
            local flags=()

            logger INFO "${pkgname}: No longer used:"

            if [[ "$instflags" == *D* ]]; then
                flags+=( -d )
            fi

            logger-push
            dpm-remove "${flags[@]}" "$pkgname" || isok=0
            logger-pop
        fi
    done < <(installed-list)

    # Success!
    if (( isok )); then
        logger GOOD "CLEANUP SUCCESS!"
        return 0
    fi

    # Notification
    logger FAIL "${pkgname}: FAILED to cleanup, see above for errors."

    return 1
}


function dpm-list() {
    local optstring long=0
    local format="  %*s  %*s  %*s  %-*s"
    local header=( "PACKAGE" "COUNT" "DEPTH" "FLAGS" )
    local hline=(  "-------" "-----" "-----" "-----" )
    local widths=( 15 5 5 5 )
    local delim=$'\x02'
    local rows=()
    local isok=1

    # Parse arguments
    optstring=$(egetopt "l" "long" "$@") || return 1
    eval set -- "$optstring"

    while (( $# )); do
        [[ "$1" == "--" ]] && shift && break

        case "$1" in
            -l|--long)  long=1  ;;
        esac

        shift
    done

    # Long option initialization
    if (( long )); then
        local i

        format+="  %-*s  %-*s"
        header+=( "BRANCH" "URL" )
        widths=()

        for (( i=0; i < ${#header[@]}; i++ )); do
            widths+=( ${#header[i]} )
        done
    fi

    #
    # In long option mode, we build the list of packages first so we can
    # calculate the maximum display width for each column before printing them.
    # Otherwise we print them outright for speed.
    #

    # Adjust the first column width in short option
    if (( ! long )); then
        local width=${#header[0]}
        local pkgname

        while IFS= read -r pkgname; do
            (( width < ${#pkgname} )) && width=${#pkgname}
        done < <(installed-list)

        widths[0]=$width
    fi

    # Header in short option
    if (( ! long )); then
        iprintf "$format\n" "${widths[@]}" "${header[@]}"
        iprintf "$format\n" "${widths[@]}" "${hline[@]}"
    fi

    # Build installed package list
    if true; then
        local pkgname

        while IFS= read -r pkgname; do
            local count=$(instfile-refcount "$pkgname")
            local depth=$(instfile-refdepth "$pkgname")
            local flags=$(instfile-getflags "$pkgname")

            # If there are issues
            (( count <= 0 )) && isok=0

            if (( long )); then
                local url=$(pkg-geturl "$pkgname")
                local branch=$(pkg-getbranch "$pkgname")

                # If there are issues
                [[ -z "$url"     ]] && url="?"    && isok=0
                [[ -z "$branch"  ]] && branch="?" && isok=0

                rows+=( "${pkgname}${delim}${count}${delim}${depth}${delim}${flags}${delim}${branch}${delim}${url}" )
                (( ${widths[0]} < ${#pkgname}  )) && widths[0]=${#pkgname}
                (( ${widths[1]} < ${#count}    )) && widths[1]=${#count}
                (( ${widths[2]} < ${#depth}    )) && widths[2]=${#depth}
                (( ${widths[3]} < ${#flags}    )) && widths[3]=${#flags}
                (( ${widths[4]} < ${#branch}   )) && widths[4]=${#branch}
                (( ${widths[5]} < ${#url}      )) && widths[5]=${#url}
            else
                iprintf "$format\n" "${widths[@]}" "$pkgname" "$count" "$depth" "$flags"
            fi
        done < <(installed-list)
    fi

    # Build missing packages list
    if true; then
        local pkgname

        while IFS= read -r pkgname; do
            local count=$(instfile-refcount "$pkgname")
            local depth=$(instfile-refdepth "$pkgname")
            local flags=$(instfile-getflags "$pkgname")

            if (( long )); then
                rows+=( "${pkgname}${delim}${count}${delim}${depth}${delim}${flags}${delim}-${delim}-" )
                (( ${widths[0]} < ${#pkgname}  )) && widths[0]=${#pkgname}
                (( ${widths[1]} < ${#count}    )) && widths[1]=${#count}
                (( ${widths[2]} < ${#depth}    )) && widths[2]=${#depth}
                (( ${widths[3]} < ${#flags}    )) && widths[3]=${#flags}
            else
                iprintf "$format\n" "${widths[@]}" "$pkgname" "$count" "$depth" "$flags"
            fi

            isok=0
        done < <(missing-list)
    fi

    # Print header
    if (( long )); then
        local output
        local hval=()
        local hbar=()
        local i

        # Interleave with column widths
        for (( i=0; i < ${#widths[@]}; i++ )); do
            hval+=( "${widths[i]}" "${header[i]}" )
            hbar+=( "${widths[i]}" "$(repeat - ${widths[i]})" )
        done

        printf "$format\n" "${hval[@]}"
        printf "$format\n" "${hbar[@]}"
    fi

    # Print packages
    if (( long )); then
        local i

        for (( i=0; i < ${#rows[@]}; i++ )); do
            local cols=()
            local args=()
            local j

            # Get the column values
            IFS=${delim} read -ra cols <<<"${rows[i]}"

            # Interleave with column widths
            for (( j=0; j < ${#widths[@]}; j++ )); do
                args+=( "${widths[j]}" "${cols[j]}" )
            done

            # Print
            printf "$format\n" "${args[@]}"
        done
    fi

    (( isok ))
}


function dpm-sourceme() {
    local pkgname
    local path=0
    local tclpath=0
    local pythonpath=0

    while IFS= read -r pkgname; do
        local pkgpath="${PKGDIR}/${pkgname}"

        [[ -d "${pkgpath}/bin"                   ]] && printf "%s\n" "PATH+=:${pkgpath}/bin" && path=1
        [[ -e "${pkgpath}/lib/pkgIndex.tcl"      ]] && printf "%s\n" "TCLLIBPATH+=:${pkgpath}/lib" && tclpath=1
        compgen -G "${pkgpath}/lib/*.py" >/dev/null && printf "%s\n" "PYTHONPATH+=:${pkgpath}/lib" && pythonpath=1
    done < <(installed-list)

    printf 'export DPM=%q\n' "${PKGDIR}"
    (( path )) && printf "%s\n" "export PATH"
    (( tclpath )) && printf "%s\n" "export TCLLIBPATH"
    (( pythonpath )) && printf "%s\n" "export PYTHONPATH"

    return 0
}


function dpm-sourceit() {
    local pkgname
    local isok=1

    for pkgname in "$@"; do
        local pkgpath="${PKGDIR}/${pkgname}"
        local bashrc="${pkgpath}/etc/bashrc"

        if ! pkg-isinstalled "$pkgname"; then
            logger FAIL "${pkgname}: Not installed, cannot source."
            isok=0
            continue
        fi

        [[ -r "$bashrc" ]] && cat "$bashrc" || isok=0
    done

    (( isok ))
}


##############################################################################
# HELPER FUNCTIONS

function installed-list() {
    local pkgpath

    #
    # Any directory in $PKGDIR is assumed to be a package.  Return their names.
    #

    for pkgpath in "${PKGDIR}"/*; do
        if [[ -d "$pkgpath" ]]; then
            local pkgname=$(basename "$pkgpath")

            printf "%s\n" "$pkgname"
        fi
    done
}


function missing-list() {
    local pkgname rest

    #
    # Return name of any package in the installation record that isn't
    # installed.
    #

    instfile-memoize

    if [[ -n "$INSTALLED" ]]; then
        while IFS=\| read -r pkgname rest; do
            if ! pkg-isinstalled "$pkgname"; then
                printf "%s\n" "$pkgname"
            fi
        done <<<"$INSTALLED"
    fi
}


function instfile-incr() {
    local instfile="${PKGDIR}/.installed"
    local tmpfile="${instfile}.tmp"
    local pkgname flags count depth rest
    local setflags=""
    local setdepth=0
    local updated=()
    local optstring
    local isok=1

    # Clear the memoized data
    INSTALLED=

    # Parse arguments
    optstring=$(egetopt "d:f:" "depth:,flags:" "$@") || return 1
    eval set -- "$optstring"

    while (( $# )); do
        [[ "$1" == "--" ]] && shift && break

        case "$1" in
            -d|--depth) setdepth=$2 && shift ;;
            -f|--flags) setflags=$2 && shift ;;
        esac

        shift
    done

    # Delete tmpfile in case noclobber is set
    rm -f "$tmpfile"

    # Update existing records
    while IFS=\| read -r pkgname flags count depth rest; do
        if [[ " $* " == *" $pkgname "* ]]; then
            depth=$setdepth
            count=$(( count + 1 ))
            [[ "$flags" != *"$setflags"* ]] && flags+=$setflags

            updated+=( "$pkgname" )
        fi

        printf "%s|%s|%s|%s|%s\n" "$pkgname" "$flags" "$count" "$depth" "$rest"
    done < "$instfile" >> "$tmpfile" || isok=0

    # Add new records
    for pkgname in "$@"; do
        if [[ " ${updated[*]} " != *" $pkgname "* ]]; then
            printf "%s|%s|%s|%s|%s\n" "$pkgname" "$setflags" "1" "$setdepth" ""
        fi
    done >> "$tmpfile" || isok=0

    (( isok )) && mv -f "$tmpfile" "$instfile"
}


function instfile-decr() {
    local instfile="${PKGDIR}/.installed"
    local tmpfile="${instfile}.tmp"
    local pkgname flags count depth rest
    local clearflags=""
    local optstring
    local isok=1

    # Clear the memoized data
    INSTALLED=

    # Parse arguments
    optstring=$(egetopt "f:" "flags:" "$@") || return 1
    eval set -- "$optstring"

    while (( $# )); do
        [[ "$1" == "--" ]] && shift && break

        case "$1" in
            -f|--flags) clearflags=$2 && shift ;;
        esac

        shift
    done

    # Update the installation file
    while IFS=\| read -r pkgname flags count depth rest; do
        if [[ " $* " == *" $pkgname "* ]]; then
            count=$(( count - 1 ))
            flags=${flags//$clearflags/}
        fi

        if (( count > 0 )); then
            printf "%s|%s|%s|%s|%s\n" "$pkgname" "$flags" "$count" "$depth" "$rest"
        fi
    done < "$instfile" > "$tmpfile" || isok=0

    (( isok )) && mv -f "$tmpfile" "$instfile"
}


function instfile-get() {
    local pkgname=$1
    local index=$2
    local row=()

    instfile-memoize

    while IFS=\| read -ra row; do
        if [[ "${row[0]}" == "$pkgname" ]]; then
            printf "%s" "${row[index]}"
            break
        fi

        false
    done <<<"$INSTALLED"
}


function instfile-getflags() {
    local pkgname=$1

    instfile-get "$pkgname" 1
}


function instfile-refcount() {
    local pkgname=$1
    local value=$(instfile-get "$pkgname" 2)

    [[ -z "$value" ]] && value=0

    printf "%s" "$value"
}


function instfile-refdepth() {
    local pkgname=$1
    local value=$(instfile-get "$pkgname" 3)

    [[ -z "$value" ]] && value=0

    printf "%s" "$value"
}


function instfile-memoize() {
    local instfile="${PKGDIR}/.installed"

    # Memoize the data
    if [[ -z "$INSTALLED" ]]; then
        INSTALLED=$(cat "$instfile")
    fi
}


function url-gethandler() {
    local url=$1
    local handler

    for handler in "${HANDLERS[@]}"; do
        if "${handler}-testurl" "$url"; then
            printf "%s\n" "$handler"
            break
        fi

        handler=""
    done

    [[ -n "$handler" ]]
}


function pkg-gethandler() {
    local pkgname=$1
    local handler

    for handler in "${HANDLERS[@]}"; do
        if "${handler}-testpkg" "$pkgname"; then
            printf "%s\n" "$handler"
            break
        fi

        handler=""
    done

    [[ -n "$handler" ]]
}


function pkg-isinstalled() {
    local pkgname=$1

    [[ -n "$pkgname" ]] && [[ -d "${PKGDIR}/${pkgname}" ]]
}


function pkg-geturl() {
    local pkgname=$1
    local handler=$(pkg-gethandler "$pkgname")

    [[ -n "$handler" ]] && "${handler}-geturl" "$pkgname"
}


function pkg-getbranch() {
    local pkgname=$1
    local handler=$(pkg-gethandler "$pkgname")

    [[ -n "$handler" ]] && "${handler}-getbranch" "$pkgname"
}


function pkg-getdeps() {
    local pkgname=$1
    local depfile="${PKGDIR}/${pkgname}/etc/dpm-deps"

    if [[ -r "$depfile" ]]; then
        cat "$depfile"
    fi
}


##############################################################################
# GIT HANDLERS

function git-testdeps() {
    local isok=1

    # Check for git
    if ! command -v git >/dev/null; then
        logger FAIL "Please install 'git'"
        isok=0
    fi

    (( isok ))
}


function git-testurl() {
    local url=$1

    [[ "$url" == *.git ]]
}


function git-testpkg() {
    local pkgname=$1
    local pkgpath="${PKGDIR}/${pkgname}"

    [[ -d "${pkgpath}/.git" ]]
}


function git-urlpkg() {
    local url=$1

    # URLs that don't support <project>.git format can be cloned as <project>/.git
    if [[ "$url" == */.git ]]; then
        url=$(dirname "$url")
    fi

    basename "$url" .git
}


function git-install() {
    local url=$1 pkgname=$2 branch=${3-}
    local args=()

    # Extra arguments to git
    [[ -n "$branch" ]] && args+=( -b "$branch" )

    # Clone
    git -C "$PKGDIR" clone "${args[@]}" "$url" "$pkgname"
}


function git-remove() {
    local pkgname=$1
    local pkgpath="${PKGDIR}/${pkgname}"
    local numchanges
    local isok=1

    # Test the repository for changes
    numchanges=$(git -C "$pkgpath" status --porcelain | wc -l) || isok=0

    # Remove the repository
    if (( isok )) && (( numchanges == 0 )); then
        rm -rf "$pkgpath" || isok=0
    elif (( isok )); then
        printf "%s\n" "${pkgname}: Has uncommitted changes, will not remove." 1>&2
        isok=0
    fi

    (( isok ))
}


function git-update() {
    local pkgname=$1

    # Clone
    git -C "${PKGDIR}/${pkgname}" pull
}


function git-geturl() {
    local pkgname=$1
    local pkgpath="${PKGDIR}/${pkgname}"

    git -C "$pkgpath" remote -v | awk '/\(fetch\)$/ { print $2 }'
}


function git-getbranch() {
    local pkgname=$1
    local pkgpath="${PKGDIR}/${pkgname}"

    git -C "$pkgpath" branch 2>/dev/null | awk '/^[*]/ { print $2 }'
}


##############################################################################
# GENERIC UTILITIES

function logger() {
    local level=$1 && shift
    local cbegin="" cend=""
    local line

    # Colorize
    case "$level" in
        GOOD)   [[ -t 1 ]] && cbegin="\033[1;32m" && cend="\033[0m" ;;
        WARN)   [[ -t 2 ]] && cbegin="\033[1;33m" && cend="\033[0m" ;;
        FAIL)   [[ -t 2 ]] && cbegin="\033[1;31m" && cend="\033[0m" ;;
    esac

    #
    # Print arguments or stdin.
    #
    while IFS= read -r line; do
        case "$level" in
            WARN|FAIL)  printf "${cbegin}%*s[%4s] %s${cend}\n" "$LOGGER_INDENT" "" "${level::4}" "$line" 1>&2 ;;
            *)          printf "${cbegin}%*s[%4s] %s${cend}\n" "$LOGGER_INDENT" "" "${level::4}" "$line"      ;;
        esac
    done < <( (( $# )) && printf "%s\n" "$@" || cat )
}


function logger-push() {
    local count=${1-1}

    (( LOGGER_INDENT += 2 * count )) || :
}


function logger-pop() {
    local count=${1-1}

    (( LOGGER_INDENT -= 2 * count )) || :
}


function egetopt() {
    local shortopts=$1 && shift
    local longopts=$1 && shift

    #
    # Use GNU "getopt" if available, otherwise fall back to "getopts" built-in.
    # GNU gives us long options but it's not always available.
    #

    if command -v getopt >/dev/null && getopt -T >/dev/null; (( $? == 4 )); then
        getopt -o "$shortopts" --long "$longopts" -- "$@"
    else
        local OPTARG OPTIND OPTERR opt
        local output=()
        local isok=1

        while getopts "$shortopts" opt; do
            output+=( "-${opt}" )
            [[ "$shortopts" == *"${opt}:"* ]] && output+=( "$OPTARG" )
            [[ "$shortopts" != *"${opt}"* ]] && isok=0
        done
        shift $(( OPTIND - 1 ))

        printf " %q" "${output[@]}" -- "$@"
        printf "\n"

        (( isok ))
    fi
}


function repeat() {
    local char=$1
    local count=$2
    local output=""
    local i

    for (( i=0; i < count; i++ )); do
        output+="$char"
    done

    printf "%s" "$output"
}


function iprintf() {
    local format=$1 && shift
    local count=$(( $# / 2 ))
    local argv=( "$@" )
    local args=()
    local i

    # Call printf with its arguments interleaved.

    for (( i=0; i < count; i++ )); do
        args+=( "${argv[i]}" "${argv[i+count]}" )
    done

    printf -- "$format" "${args[@]}"
}


##############################################################################
# ENTRY POINT

main "$@"
