#!/bin/bash

##############################################################################
# Distributed Package Manager
# https://github.com/markuskimius/dpm
#
# Copyright (c)2021 Mark K. Kim
# Released under GNU General Public License version 2.
# https://github.com/markuskimius/dpm/blob/main/LICENSE
##############################################################################

function usage() {
    SCRIPTNAME=$(basename -- "$0")

    cat <<EOF
Usage: ${SCRIPTNAME} COMMAND [ARGUMENTS]

COMMAND:
  install [-b,--branch=BRANCH] URL [PKGNAME]
                        Install PKGNAME from URL and its dependencies, if any.
                        If PKGNAME is omitted a name is chosen based on the
                        URL.

  remove PKGNAME        Remove PKGNAME and any of its unused dependencies.

  rename PKGNAME1 PKGNAME2
                        Rename PKGNAME1 to PKGNAME2 if possible.

  update [PKGNAME]      Update PKGNAME, installing any new dependency.  Any
                        stale dependency is not removed.  Use '${SCRIPTNAME}
                        cleanup' to remove any stale dependency that is no
                        longer required.  If PKGNAME is omitted all packages
                        are updated.

  recover               Rebuild the file that tracks installed packages and
                        their dependencies.  Any missing dependency is
                        installed but stale dependency is not removed; use
                        '${SCRIPTNAME} cleanup' to remove any stale dependency
                        that is no longer required.

  cleanup               Delete any package installed as a dependency but is no
                        longer required.

  list [-l,--long]      List installed packages.

  deps [PKGNAME]        Show the dependency tree of any direct installed
                        package that directly or indirectly depends on PKGNAME.
                        If PKGNAME is omitted, the dependency tree of all
                        direct installed packages is displayed.

  setup                 eval this output to setup BASH.  The output contains
                        the script to setup DPM core as well as the script to
                        setup any active package.

  activate PKGNAME      Activate PKGNAME.

  deactivate PKGNAME    Deactivate PKGNAME.

FILES:
  Config files:$(printf "\n    %s" "${CONFIGS[@]}")

EOF
}


##############################################################################
# PROGRAM BEGINS HERE

SCRIPTPATH=$0
SCRIPTARGV=( "$@" )
PKGDIR=${DPM-${HOME}/dpm}
HANDLERS=( git pip local )
LOCK=0
CONFIGS=(
    ~/.dpmrc
    /usr/local/etc/dpmrc
    /usr/etc/dpmrc
    /etc/dpmrc
)


function main() {
    local OPTIND OPTERR OPTARG opt
    local action=( usage )
    local isok=1

    # Check arguments
    while getopts "p:nL" opt; do
        case "$opt" in
            p)  PKGDIR=$OPTARG ;;
            n)  LOCK=0         ;;
            L)  LOCK=1         ;;
            *)  isok=0         ;;
        esac
    done
    shift $((OPTIND-1))

    # Check command
    case "${1-}" in
        install)    shift && action=( dpm-install      ) ;;
        remove)     shift && action=( dpm-remove       ) ;;
        rename)     shift && action=( dpm-rename       ) ;;
        update)     shift && action=( dpm-update       ) ;;
        recover)    shift && action=( dpm-recover      ) ;;
        cleanup)    shift && action=( dpm-cleanup      ) ;;
        list)       shift && action=( dpm-list         ) ;;
        deps)       shift && action=( dpm-deps         ) ;;
        setup)      shift && action=( dpm-setup        ) ;;
        activate)   shift && action=( dpm-activate     ) ;;
        deactivate) shift && action=( dpm-deactivate   ) ;;
        help)       usage && exit                        ;;
        *)          logger FAIL "${1-(none)}: Invalid COMMAND"
                    isok=0
    esac

    # Validate arguments
    if (( ! isok )); then
        usage 1>&2
        exit 1
    fi

    #
    # Initialize.  Note that lock-pkgdir may restart the script so any code
    # that runs before it must be idempotent.
    #
    # load-config and ensure-deps must run before lock-pkgdir because
    # lock-pkgdir depends on them.
    #
    load-config          || exit 1
    ensure-deps          || exit 1
    if (( LOCK )); then
        lock-pkgdir
    fi                   || exit 1
    instfile-open        || exit 1

    "${action[@]}" "$@"
}


function load-config() {
    local isok=1
    local file

    # Defaults
    set -o pipefail

    # Initialize
    LOGGER_INDENT=0

    # Source the first file found in CONFIGS[], if any
    for file in "${CONFIGS[@]}"; do
        if [[ -e "$file" ]]; then
            source "$file" || isok=0
            break
        fi
    done

    (( isok ))
}


function ensure-deps() {
    local handler
    local isok=1

    # Check for flock or shlock
    if (( LOCK )) && ! command -v flock >/dev/null && ! command -v shlock >/dev/null; then
        logger FAIL "flock or shlock must be installed."
        isok=0
    fi

    # Check for handler dependencies
    for handler in "${HANDLERS[@]}"; do
        local depfn="${handler}-testdeps"

        if ! command -v "$depfn" >/dev/null; then
            logger FAIL "${handler}: Bad handler" && isok=0
            continue
        fi

        "$depfn" || isok=0
    done

    # Ensure $PKGDIR is set
    if [[ ! -n "$PKGDIR" ]]; then
        logger FAIL "\$PKGDIR must be set"
        isok=0
    fi

    # Ensure $PKGDIR exists
    if [[ ! -d "$PKGDIR" ]] && ! mkdir -p "$PKGDIR" 2>/dev/null; then
        logger FAIL "Unable to create $PKGDIR"
        isok=0
    fi

    # Ensure the installed file exists
    if [[ ! -w "${PKGDIR}/.installed" ]] && ! touch "${PKGDIR}/.installed" 2>/dev/null; then
        logger FAIL "Unable to create ${PKGDIR}/.installed"
        isok=0
    fi

    (( isok ))
}


function lock-pkgdir() {
    local lockfile="${PKGDIR}/.lock"
    local locked=0

    #
    # 'flock' is preferred but (1) it requires restarting the script and (2) it
    # may not be available on some systems.  This script must be written such
    # that (1) is not an issue.
    #
    # As for (2), we fall back on 'shlock' if 'flock' is not available.
    # 'shlock' is less preferred because it may run into a race condition on
    # some platforms.  Also, as with 'flock', it may not be available on some
    # systems.
    #

    if command -v flock >/dev/null; then
        if [[ "$FLOCKER" == "$lockfile" ]]; then
            locked=1
        else
            export FLOCKER=$lockfile
            exec flock "$lockfile" "$SCRIPTPATH" "${SCRIPTARGV[@]}"
        fi
    elif command -v shlock >/dev/null; then
        while true; do
            shlock -p $$ -f "$lockfile" && locked=1 && break
            sleep 1
        done
    else
        logger FAIL "No locking command available"
    fi

    (( locked ))
}


##############################################################################
# INSTALL

function dpm-install() {
    local optstring url pkgname branch
    local isok=1

    # Parse arguments
    optstring=$(egetopt "b:" "branch:" "$@") || return 1
    eval set -- "$optstring"

    while (( $# )); do
        [[ "$1" == "--" ]] && shift && break

        case "$1" in
            -b|--branch)  branch=$2 && shift ;;
        esac

        shift
    done

    # Optionless arguments
    url=$1
    pkgname=${2-}

    # The first argument may be a URL or a packagename
    if [[ -z "$pkgname" ]] && pkg-isinstalled "$url"; then
        pkgname=$url
        url=""
    fi

    # Validate arguments
    [[ -z "$url" && -z "$pkgname" ]] && logger FAIL "Must specify URL or PKGNAME" && return 1
    (( $# > 2 )) && logger FAIL "Too many arguments" && return 1

    # Default the package name if not set
    if [[ -z "$pkgname" ]]; then
        pkgname=$(url-pkgname "$url") || return 1
    fi

    # Package cannot be direct installed more than once
    if instfile-seek "$pkgname" && [[ "$(instfile-get FLAGS)" == *D* ]]; then
        logger FAIL "${pkgname}: Already direct installed"
        return 0
    fi

    # Install or increment reference counter
    install-or-incref -r "$pkgname" "$url" "$branch" || isok=0

    if (( isok )); then
        # Update the flag
        logger INFO "${pkgname}: Set direct install flag..."
        instfile-seek "$pkgname"
        instfile-setflags D
        instfile-save || isok=0

        if (( isok )); then
            # Success!
            logger OK "Done"
            return 0
        fi

        # Failed!
        logger FAIL "${pkgname}: Failed to set direct install flag, revert..."
        decref-by-pkgname -r "$pkgname"
    fi

    return 1
}


function install-or-incref() {
    local OPTIND OPTERR OPTARG opt
    local pkgname url branch sources
    local recursive=()
    local numrefs=1

    # Check arguments
    while getopts "n:r" opt; do
        case "$opt" in
            n)  numrefs=$OPTARG   ;;
            r)  recursive+=( -r ) ;;
        esac
    done
    shift $((OPTIND-1))

    # Optionless arguments
    pkgname=$1
    url=${2-}
    branch=${3-}
    sources=${4-"$url $branch"}

    # Install or update reference recursively
    if pkg-isinstalled "$pkgname"; then
        local insturl instbranch

        #
        # If the dependency is already installed from a compatible source
        # we just need to update the reference counters.  If it's installed
        # from an incompatible source then we fail.
        #

        pkginfo-seek "$pkgname"
        insturl=$(pkginfo-get URL)
        instbranch=$(pkginfo-get BRANCH)

        if [[ " $sources " == *" $insturl $instbranch "* \
           || " $sources " == *" $insturl * "*           \
           || " $sources " == *" $insturl  "             \
           || " $sources " == *" $insturl "              \
           || " $sources " ==  "   "                     \
           ]]; then
            incref-by-pkgname -n "$numrefs" "${recursive[@]}" "$pkgname"
        else
            logger FAIL "${pkgname}: Already installed but from an incompatible source ${insturl} branch ${instbranch}"
            false
        fi
    else
        install-by-url -n "$numrefs" "${recursive[@]}" "$pkgname" "$url" "$branch"
    fi || isok=0

    (( isok ))
}


function install-by-url() {
    local OPTIND OPTERR OPTARG opt
    local pkgname url branch
    local recursive=0
    local numrefs=1
    local handler
    local isok=1

    # Check arguments
    while getopts "n:r" opt; do
        case "$opt" in
            n)  numrefs=$OPTARG ;;
            r)  recursive=1     ;;
        esac
    done
    shift $((OPTIND-1))

    # Optionless arguments
    pkgname=$1
    url=$2
    branch=${3-}

    # Sanity check
    handler=$(url-gethandler "$url") || return 1
    ! command -v "${handler}-install" >&/dev/null && logger FAIL "${handler}-install missing" && return 1
    ! [[ "$pkgname" =~ ^[-_.A-Za-z0-9]+$ ]] && logger FAIL "${pkgname}: Invalid package name" && return 1

    # Notification
    [[ -z "$branch" ]] && unset branch
    logger INFO "INSTALL ${pkgname} from ${url}${branch+ branch }${branch-}..."

    # Install the package
    "${handler}-install" "$url" "$pkgname" "${branch-}" 2>&1 | logger "${handler}" || isok=0

    if (( isok )); then
        # Insert a installation record
        logger INFO "${pkgname}: Insert a installation record..."
        instfile-rmrec "$pkgname"
        instfile-seek "$pkgname"
        instfile-set PKGNAME "$pkgname"
        instfile-set NUMREF "$numrefs"
        instfile-set HEIGHT 1
        instfile-save || isok=0

        if (( isok )); then
            # Install dependencies
            if (( recursive )); then
                install-deps-by-pkgname -n "$numrefs" "$pkgname"
            fi || isok=0

            if (( isok )); then
                # Success!
                logger OK "SUCCESS: Installed ${pkgname}"
                return 0
            fi

            # Revert the inserted installation record
            logger INFO "${pkgname}: Revert the inserted installation record..."
            instfile-rmrec "$pkgname"
            instfile-save
        fi

        # Revert the installed package
        logger INFO "${pkgname}: Revert the installed package..."
        "${handler}-remove" "$pkgname" 2>&1 | logger "${handler}"
    fi

    # Failed!
    logger FAIL "FAILED to install ${pkgname}"
    return 1
}


function install-deps-by-pkgname() {
    local OPTIND OPTERR OPTARG opt
    local pkgname
    local installed=()
    local maxheight=0
    local numrefs=1
    local depname
    local isok=1

    # Check arguments
    while getopts "n:" opt; do
        case "$opt" in
            n)  numrefs=$OPTARG ;;
        esac
    done
    shift $((OPTIND-1))

    # Optionless arguments
    pkgname=$1

    # Open the dependency file
    depfile-open "$pkgname"

    # Install each dependency
    for depname in $(depfile-pkgnames); do
        local depurl depbranch depsources

        # Notification
        logger INFO "${pkgname}: Requires ${depname}..."
        logger-push

        # Get information about the dependency
        depfile-open "$pkgname"
        depfile-seek "$depname"
        depurl=$(depfile-geturl)           # Default URL
        depbranch=$(depfile-getbranch)     # Default branch
        depsources=$(depfile-get SOURCES)  # All sources

        # Install or increment reference counter recursively
        install-or-incref -n "$numrefs" -r "$depname" "$depurl" "$depbranch" "$depsources" \
        && installed+=( "$depname" )                                                       \
        || isok=0

        if (( isok )); then
            # Update maxheight
            instfile-seek "$depname"
            maxheight=$(max "$maxheight" "$(instfile-get HEIGHT)")

            # Success!
            logger-pop
            continue
        fi

        # Failed!
        logger-pop
        break
    done

    if (( isok )); then
        # Update the height
        if (( ${#installed[@]} )); then
            logger INFO "${pkgname}: Update the installion record..."
            instfile-seek "$pkgname"
            instfile-set HEIGHT $((maxheight + 1))
            instfile-save
        fi || isok=0

        if (( isok )); then
            # Success!
            return 0
        fi

        # ;&
    fi

    # Failed!
    logger FAIL "${pkgname}: Failed to install dependencies, revert..."
    logger-push

    # Revert updates and installs
    for depname in "${installed[@]}"; do
        #
        # The package may have been installed or its reference incremented.
        # Either way, we revert nondestructively by decrementing the reference
        # without removing the package.
        #

        decref-by-pkgname -n "$numrefs" -r "$depname"
    done

    logger-pop
    return 1
}


##############################################################################
# REMOVE

function dpm-remove() {
    local pkgname
    local isok=1

    # Validate arguments
    (( $# == 0 )) && logger FAIL "Must specify PKGNAME" && return 1

    # Remove the packages
    for pkgname in "$@"; do
        local flags numref

        # Validate package
        ! pkg-isinstalled "$pkgname" && logger WARN "${pkgname}: No such package, skip" && continue

        # Get some information about the package
        instfile-seek "$pkgname"
        flags=$(instfile-get FLAGS)
        numref=$(instfile-get NUMREF)

        # Must be direct installed
        [[ "$flags" != *D* ]] && logger FAIL "${pkgname}: Must be direct installed to remove" && isok=0 && break

        # Remove or decrement
        if (( numref <= 1 )); then
            remove-by-pkgname -r "$pkgname"
        else
            decref-by-pkgname -r "$pkgname" || isok=0

            if (( isok )); then
                # Update the flag
                logger INFO "${pkgname}: Clear direct install flag..."
                instfile-seek "$pkgname"
                instfile-clearflags D
                instfile-save
            fi || isok=0

            (( isok ))
        fi || isok=0

        if (( isok )); then
            # Success
            continue
        fi

        # Failed
        break
    done

    if (( isok )); then
        # Success!
        logger OK "Done"
    fi

    # Failed!
    (( isok ))
}


function remove-by-pkgname() {
    local OPTIND OPTERR OPTARG opt
    local pkgname
    local recursive=0
    local handler
    local isok=1

    # Check arguments
    while getopts "r" opt; do
        case "$opt" in
            r)  recursive=1 ;;
        esac
    done
    shift $((OPTIND-1))

    # Optionless arguments
    pkgname=$1

    # Sanity check
    ! pkg-isinstalled "$pkgname" && logger WARN "${pkgname}: Already removed" && return 0
    handler=$(pkg-gethandler "$pkgname") || return 1
    ! command -v "${handler}-remove" >&/dev/null && logger FAIL "${handler}-remove missing" && return 1

    # Remove the dependencies first
    logger INFO "REMOVE ${pkgname}..."
    if (( recursive )); then
        remove-deps-by-pkgname "$pkgname" || isok=0
    fi

    if (( isok )); then
        # Remove the package
        "${handler}-remove" "$pkgname" 2>&1 | logger "${handler}" || isok=0

        if (( isok )); then
            local flags

            # Remember the flags before removing the installation record
            instfile-seek "$pkgname"
            flags=$(instfile-get FLAGS)

            # Remove the installation record
            logger INFO "${pkgname}: Remove the installation record..."
            instfile-rmrec "$pkgname"
            instfile-save || isok=0

            # If we removed an active package, regenerate the active file
            if [[ "$flags" == *A* ]]; then
                logger WARN "${pkgname}: Deactivated"
                active-save
            fi

            if (( isok )); then
                # Success!
                logger OK "SUCCESS: Removed ${pkgname}"
                return 0
            fi

            # ;&
        fi

        # ;&
    fi

    # Failed!
    logger FAIL "FAILED to remove ${pkgname}"
    return 1
}


function remove-deps-by-pkgname() {
    local pkgname=$1
    local depname
    local isok=1

    # Open the dependency file.  If can't, the package has no dependencies.
    depfile-open "$pkgname"

    # Remove each dependency
    for depname in $(depfile-pkgnames); do
        local numref

        # Notification
        logger INFO "${pkgname}: References ${depname}..."
        logger-push

        # Get information about the dependency
        instfile-seek "$depname"
        numref=$(instfile-get NUMREF)

        # Remove the package or decrement the reference counter?
        if (( numref <= 1 )); then
            remove-by-pkgname -r "$depname"
        else
            decref-by-pkgname -r "$depname"
        fi || isok=0

        if (( isok )); then
            # Success
            logger-pop
            continue
        fi

        # Failed
        logger-pop
        break
    done

    # Success!
    if (( isok )); then
        return 0
    fi

    # Failed!
    return 1
}


##############################################################################
# RENAME

function dpm-rename() {
    local pkgname1=$1
    local pkgname2=$2
    local isok=1

    # Validate arguments
    [[ -z "$pkgname1" ]] && logger FAIL "Must specify PKGNAME1" && return 1
    [[ -z "$pkgname2" ]] && logger FAIL "Must specify PKGNAME2" && return 1
    (( $# > 2         )) && logger FAIL "Too many arguments"   && return 1
    ! pkg-isinstalled "$pkgname1" && logger FAIL "${pkgname1}: PKGNAME1 invalid, must exist" && return 1
    pkg-isinstalled "$pkgname2"   && logger FAIL "${pkgname2}: PKGNAME2 invalid, already exists" && return 1

    # Get some information about the package
    pkginfo-seek "$pkgname1"

    # The package must be direct installed with no dependencies
    if [[ "$(pkginfo-get FLAGS)" != *D* ]] || (( $(pkginfo-get NUMREF) != 1 )); then
        logger FAIL "${pkgname1}: Must be direct installed with no more than one reference"
        return 1
    fi

    # Notification
    logger INFO "RENAME ${pkgname1} to ${pkgname2}..."

    # Move the package
    logger INFO "${pkgname1}: Move directory to ${pkgname2}..."
    mv -f "${PKGDIR}/${pkgname1}" "${PKGDIR}/${pkgname2}" || isok=0

    if (( isok )); then
        # Update the installation record
        logger INFO "${pkgname1}: Rename install record to ${pkgname2}..."
        instfile-mvrec "$pkgname1" "$pkgname2"
        instfile-save || isok=0

        if (( isok )); then
            # Update the active record
            if [[ "$(instfile-get FLAGS)" == *A* ]]; then
                logger INFO "${pkgname1}: Rename the active record to ${pkgname2}..."
                active-save || isok=0
            fi

            if (( isok )); then
                # Success!
                logger OK "SUCCESS: Renamed ${pkgname1} to ${pkgname2}"
                return 0
            fi

            # Revert the installation record
            instfile-mvrec "$pkgname2" "$pkgname1"
            instfile-save
        fi

        # Revert the directory move
        mv -f "${PKGDIR}/${pkgname2}" "${PKGDIR}/${pkgname1}"
    fi

    # Failed!
    logger FAIL "FAILED to rename"
    return 1
}


##############################################################################
# UPDATE

function dpm-update() {
    local pkgname
    local isok=1

    # Update all packages if none specified
    if (( $# == 0 )); then
        set -- $(installed)
    fi

    # Validate arguments
    (( $# == 0 )) && logger FAIL "No package to update" && return 1

    # Do my thing
    for pkgname in "$@"; do
        # Validate package
        ! pkg-isinstalled "$pkgname" && logger FAIL "${pkgname}: Invalid PKGNAME" && isok=0 && break

        # Update the package
        update-by-pkgname "$pkgname" || isok=0

        if (( isok )); then
            # Success!
            continue
        fi

        # Failed!
        logger FAIL "FAILED to update ${pkgname}"
        break
    done

    (( isok ))
}


function update-by-pkgname() {
    local pkgname=$1
    local handler
    local predeps=()
    local postdeps=()
    local oldheight newheight

    # Validate arguments
    handler=$(pkg-gethandler "$pkgname") || return 1
    ! command -v "${handler}-update" >&/dev/null && logger FAIL "${handler}-update missing" && return 1

    # Notification
    logger INFO "UPDATE '${pkgname}'..."

    # Get the list of dependencies before update
    if depfile-open "$pkgname"; then
        predeps=( $(depfile-pkgnames) )
    fi

    # Get the height before the update
    instfile-seek "$pkgname"
    oldheight=$(instfile-get HEIGHT)
    newheight=$oldheight

    # Update the package
    "${handler}-update" "$pkgname" 2>&1 | logger "${handler}" || isok=0

    if (( isok )); then
        local depname depurl depbranch depsources depheight

        # Get the list of dependencies after update
        if depfile-open "$pkgname"; then
            postdeps=( $(depfile-pkgnames) )
        fi

        # Install new dependencies
        for depname in "${postdeps[@]}"; do
            if [[ " ${predeps[*]} " != *" $depname "* ]]; then
                depfile-open "$pkgname"
                depfile-seek "$depname"
                depurl=$(depfile-geturl)
                depbranch=$(depfile-getbranch) && [[ -z "$depbranch" ]] && unset depbranch
                depsources=$(depfile-get SOURCES)

                logger INFO "${pkgname}: Now requires '${depname}' from ${depurl}${depbranch+ branch }${depbranch-}:"
                logger-push
                install-or-incref -r "$depname" "$depurl" "$depbranch" "$depsources" || isok=0
                logger-pop

                # Did the height increase?
                instfile-seek "$depname"
                depheight=$(instfile-get HEIGHT)
                newheight=$(max "$newheight" "$((depheight+1))")
            fi

            (( isok )) || break
        done

        if (( isok )); then
            # Remove stale dependencies
            for depname in "${predeps[@]}"; do
                if [[ " ${postdeps[*]} " != *" $depname "* ]]; then
                    logger INFO "${pkgname}: No longer requires '${depname}':"
                    logger-push
                    decref-by-pkgname -r "$depname" || isok=0
                    logger-pop

                    # We don't care if the height decreased since the height is
                    # only used to determine the relative order in which
                    # packages need to be initialized; if the height decreased
                    # it means there were packages that needed to be
                    # initialized before $pkgname that got removed so our
                    # relative order in which the packages need to be
                    # initialized is still maintained by keeping the current
                    # height for $pkgname.
                fi

                (( isok )) || break
            done

            if (( isok )); then
                # Update the height
                if (( oldheight != newheight )); then
                    incheight-by-pkgname -r "$pkgname" "$newheight"
                fi || isok=0

                if (( isok )); then
                    # Success!
                    logger OK "${pkgname}: UPDATED"
                    return 0
                fi

                # ;&
            fi

            # ;&
        fi

        # ;&
    fi

    # Failed!
    logger FAIL "${pkgname}: FAILED to update"
    return 1
}


##############################################################################
# RECOVER

function dpm-recover() {
    local pkgname
    local isok=1

    # Validate arguments
    (( $# )) && logger FAIL "Too many arguments" && return 1

    # Notification
    logger INFO "RECOVER..."

    # Backup the install file
    logger INFO "Backup the install file..."
    instfile-backup || isok=0

    if (( isok )); then
        # Reset height and reference counters
        logger INFO "Reset height and reference counters..."
        for pkgname in $(instfile-pkgnames); do
            instfile-seek "$pkgname"
            instfile-set HEIGHT 0
            instfile-set NUMREF 0
        done

        # Rebuild the height and reference of direct installed packages
        for pkgname in $(instfile-direct); do
            recover-by-pkgname "$pkgname" || isok=0

            (( isok )) || break
        done

        if (( isok )); then
            # Update the active file
            logger INFO "Recover the active file..."
            active-save || isok=0

            if (( isok )); then
                # Success!
                logger OK "SUCCESS: Recovered"
                return 0
            fi

            # ;&
        fi

        # Restore the backup install file
        logger FAIL "FAILED to recover, restore backup install file..."
        instfile-restore
    fi

    # Failed!
    return 1
}


function recover-by-pkgname() {
    local OPTIND OPTERR OPTARG opt
    local pkgname
    local visited=""
    local depname depurl depbranch
    local recovered=()
    local isinstalled=1
    local maxheight=0
    local isok=1

    # Check arguments
    while getopts "1" opt; do
        case "$opt" in
            v)  visited=$OPTARG   ;;
        esac
    done
    shift $((OPTIND-1))

    # Optionless arguments
    pkgname=$1

    # Sanity check
    if [[ " $visited " == *" $pkgname "* ]]; then
        logger FAIL "${pkgname}: Circular dependency"
        return 1
    fi
    if ! pkg-isinstalled "$pkgname"; then
        logger WARN "${pkgname}: Missing package, ignored"
        isinstalled=0
        # ;&
    fi

    # Notification
    logger INFO "${pkgname}: Recover..."

    # Recover the dependencies first
    depfile-open "$pkgname"

    for depname in $(depfile-pkgnames); do
        logger INFO "${pkgname}: Requires ${depname}..."
        logger-push

        if pkg-isinstalled "$depname"; then
            recover-by-pkgname "$depname" \
            && recovered+=( "$depname" )
        else
            # Get information about the dependency
            depfile-open "$pkgname"
            depfile-seek "$depname"
            depurl=$(depfile-geturl)           # Default URL
            depbranch=$(depfile-getbranch)     # Default branch

            # Install the missing dependency
            install-by-url -r "$depname" "$depurl" "$depbranch" \
            && recovered+=( "$depname" )
        fi || isok=0

        if (( isok )); then
            # Update the maxheight
            instfile-seek "$depname"
            maxheight=$(max "$maxheight" "$(instfile-get HEIGHT)")
        fi

        logger-pop
        (( isok )) || break
    done

    if (( isok )); then
        # Recover the height and the reference counter
        instfile-seek "$pkgname"
        instfile-set HEIGHT $((maxheight + 1))
        if (( isinstalled )); then
            instfile-incref
        fi
        instfile-save || isok=0

        if (( isok )); then
            # Success!
            logger OK "${pkgname}: Recovered"
            return 0
        fi
    fi

    # Rollback the reference counters
    for depname in "${recovered[@]}"; do
        logger-push
        decref-by-pkgname -r -v "$visited $pkgname" "$depname"
        logger-pop
    done

    # Failed!
    logger FAIL "${pkgname}: Failed to recover"
    return 1
}


##############################################################################
# CLEANUP

function dpm-cleanup() {
    local pkgname
    local counter=0
    local isok=1

    # Validate arguments
    (( $# )) && logger FAIL "Too many arguments" && return 1

    # Notification
    logger INFO "CLEANUP..."

    # Get the list of packages to remove
    for pkgname in $(installed); do
        pkginfo-seek "$pkgname"

        # Remove
        if (( $(pkginfo-get NUMREF) == 0 )); then
            remove-by-pkgname "$pkgname" || isok=0

            if (( isok )); then
                (( counter += 1 ))
                continue
            fi

            break
        fi
    done

    # Success!
    if (( isok )); then
        logger OK "SUCCESS: Removed ${counter} package(s)"
        return 0
    fi

    # Notification
    logger FAIL "FAILED to cleanup"
    return 1
}


##############################################################################
# LIST

function dpm-list() {
    local optstring
    local long=0
    local header=( "PKGNAME" "NUMREF" "HEIGHT" "FLAGS" )
    local format=""
    local isok=1

    # Parse arguments
    optstring=$(egetopt "l" "long" "$@") || return 1
    eval set -- "$optstring"

    while (( $# )); do
        [[ "$1" == "--" ]] && shift && break

        case "$1" in
            -l|--long)  long=1 ;;
        esac

        shift
    done

    # Validate arguments
    (( $# )) && logger FAIL "Too many arguments" && return 1

    # Long option initialization
    if (( long )); then
        header+=( "BRANCH" "URL" )
    fi

    # Lookup table
    function format-lookup() {
        case "$1" in
                URL) printf "%s" "  %-1s"  ;;
              FLAGS) printf "%s" "  %-5s"  ;;
             BRANCH) printf "%s" "  %-15s" ;;
             HEIGHT) printf "%s" "  %6s"   ;;
             NUMREF) printf "%s" "  %6s"   ;;
            PKGNAME) printf "%s" "  %15s"  ;;
                  *) logger FAIL "${1}: Invalid format"
                     return 1
        esac
    }

    # Build the format
    if true; then
        local col

        for col in "${header[@]}"; do
            format+=$(format-lookup "$col")
        done
        format+="\n"
    fi

    # Header
    if true; then
        printf "$format" "${header[@]}"
        printf "$format" "${header[@]//?/-}"
    fi

    # Build installed and missing package list
    if true; then
        local pkgname

        for pkgname in $(installed) $(instfile-missing); do
            local row=()
            local col

            pkginfo-seek "$pkgname"

            for col in "${header[@]}"; do
                if [[ "$col" == "PKGNAME" ]]; then
                    row+=( "$pkgname" )
                else
                    row+=( "$(pkginfo-get "$col")" )
                fi
            done

            printf "$format" "${row[@]}"
        done
    fi
}


##############################################################################
# DEPENDENCIES

function dpm-deps() {
    local pkgname
    local roots=()
    local colorize=0
    local isok=1

    # Get the list of direct installed roots to output
    if (( $# == 0 )); then
        # Show dependency of all packages
        roots=( $(instfile-direct) )
    else
        # Find their roots
        for pkgname in "$@"; do
            roots+=( $(deps-getroots "$pkgname") )
        done

        # Filter them to a unique sorted list
        roots=( $(printf "%s\n" "${roots[@]}" | sort -u) )
    fi

    # Colorize if output to terminal
    if [[ -t 1 ]]; then
        colorize=1
    fi

    # Do my thing
    for pkgname in "${roots[@]}"; do
        local leader
        local lnum=0
        local line

        # Validate package
        ! pkg-isinstalled "$pkgname" && logger FAIL "${pkgname}: Invalid PKGNAME" && isok=0 && break

        # Show the dependency tree of the package
        while IFS= read -r line; do
            if (( lnum == 0 )); then
                leader="* "
            else
                leader="  "
            fi

            printf "%s%s\n" "$leader" "$line"
            (( lnum+=1 ))
        done < <(deps-tree "$pkgname" "$colorize" "$*") || isok=0
    done

    (( isok ))
}


function deps-getroots() {
    local pkgname=$1
    local refname
    local roots=()
    local include=0

    # A direct installed package is a root
    instfile-seek "$pkgname"
    if [[ "$(instfile-get FLAGS)" == *D* ]]; then
        roots+=( "$pkgname" )
    fi

    # Find the roots of any package that references this package
    for refname in $(installed-by-depname "$pkgname"); do
        roots+=( $(deps-getroots "$refname") )
    done

    # Output
    printf "%s\n" "${roots[@]}"
}


function deps-tree() {
    local pkgname=$1
    local colorize=$2
    local matches=$3
    local deps=()
    local i

    # Get dependency information
    depfile-open "$pkgname"
    deps=( $(depfile-pkgnames) )

    # This node -- colorize matching nodes
    if (( colorize )) && [[ " $matches " == *" $pkgname "* ]]; then
        printf "%s\n" "$(colorize red "$pkgname")"
    else
        printf "%s\n" "$pkgname"
    fi

    # Child nodes
    for (( i=0; i < ${#deps[@]}; i++ )); do
        local depname=${deps[i]}
        local leader
        local lnum=0
        local line

        while IFS= read -r line; do
            if (( lnum == 0 )); then
                leader="+-- "
            elif (( i < ${#deps[@]}-1 )); then
                leader="|   "
            else
                leader="    "
            fi

            printf "%s%s\n" "$leader" "$line"
            (( lnum+=1 ))
        done < <(deps-tree "$depname" "$colorize" "$matches")
    done
}


##############################################################################
# SETUP

function dpm-setup() {
    local pkgname
    local path=0
    local tclpath=0
    local pythonpath=0
    local isok=1

    # Validate arguments
    (( $# )) && logger FAIL "Too many arguments" && return 1

    # DPM core
    cat-sh <<EOF
##############################################################################
# DPM CORE
##############################################################################
EOF

    for pkgname in $(installed); do
        local pkgpath="${PKGDIR}/${pkgname}"

        [[ -d "${pkgpath}/bin"                   ]] && printf "%s\n" "PATH+=:${pkgpath}/bin" && path=1
        [[ -e "${pkgpath}/lib/pkgIndex.tcl"      ]] && printf "%s\n" "TCLLIBPATH+=:${pkgpath}/lib" && tclpath=1
        compgen -G "${pkgpath}/lib/*.py" >/dev/null && printf "%s\n" "PYTHONPATH+=:${pkgpath}/lib" && pythonpath=1
    done

    printf 'export DPM=%q\n' "${PKGDIR}"
    (( path )) && printf "%s\n" "export PATH"
    (( tclpath )) && printf "%s\n" "export TCLLIBPATH"
    (( pythonpath )) && printf "%s\n" "export PYTHONPATH"

    # Active packages
    for pkgname in $(active); do
        cat-sh <<EOF

##############################################################################
# PACKAGE: $pkgname
##############################################################################
EOF

        pkg-setup "$pkgname" || isok=0
    done

    (( isok ))
}


##############################################################################
# ACTIVATE

function dpm-activate() {
    local OPTIND OPTERR OPTARG opt
    local deactivate=0
    local pkgname
    local isok=1

    # Check arguments
    while getopts "1" opt; do
        case "$opt" in
            1)  deactivate=1 ;;
        esac
    done
    shift $((OPTIND-1))

    # Validate arguments
    (( $# == 0 )) && logger FAIL "Must specify PKGNAME" && return 1

    # Activate
    for pkgname in "$@"; do
        if (( deactivate )); then
            logger INFO "DEACTIVATE ${pkgname}..."
        else
            logger INFO "ACTIVATE ${pkgname}..."
        fi

        # Validate package
        ! instfile-seek "$pkgname" && logger FAIL "${pkgname}: Invalid PKGNAME" && isok=0 && break

        # Activate/Deactivate
        if (( deactivate )); then
            instfile-clearflags A
        else
            instfile-setflags A
        fi || isok=0

        if (( isok )); then
            # Success
            continue
        fi

        # Failed
        break
    done

    if (( isok )); then
        # Save the updates
        logger INFO "SAVE install file..."
        instfile-save || isok=0

        if (( isok )); then
            logger INFO "SAVE active file..."
            active-save || isok=0

            if (( isok )); then
                # Success!
                if (( deactivate )); then
                    logger OK "SUCCESS: $# package(s) deactivated"
                else
                    logger OK "SUCCESS: $# package(s) activated"
                fi
                return 0
            fi

            # ;&
        fi

        # ;&
    fi

    # Failed!
    return 1
}


function dpm-deactivate() {
    dpm-activate -1 "$@"
}


##############################################################################
# REFERENCE

function incref-by-pkgname() {
    local OPTIND OPTERR OPTARG opt
    local pkgname
    local updated=()
    local inverse=()
    local numrefs=1
    local recursive=0
    local visited=""
    local isok=1

    # Check arguments
    while getopts "1n:rv:" opt; do
        case "$opt" in
            1)  inverse+=( -1 )   ;;
            n)  numrefs=$OPTARG   ;;
            r)  recursive=1       ;;
            v)  visited=$OPTARG   ;;
        esac
    done
    shift $((OPTIND-1))

    # Optionless arguments
    pkgname=$1

    # Sanity check
    if [[ " $visited " == *" $pkgname "* ]]; then
        logger FAIL "${pkgname}: Circular dependency"
        return 1
    fi
    if ! pkg-isinstalled "$pkgname"; then
        logger WARN "${pkgname}: Missing package, ignored"
        # ;&
    fi

    # Increment/decrement reference
    logger INFO "UPDATE ${pkgname} reference counter..."
    instfile-seek "$pkgname"
    instfile-incref "${inverse[@]}" -n "$numrefs"
    instfile-save || isok=0

    # If we lost an active package, regenerate the active file
    if (( "$(instfile-get NUMREF)" <= 0 )) && [[ "$(instfile-get FLAGS)" == *A* ]]; then
        logger WARN "${pkgname}: Deactivated"
        active-save
    fi

    if (( isok )); then
        local depname

        # Increment/decrement reference of dependencies
        if (( recursive )); then
            local maxheight=0

            depfile-open "$pkgname"

            for depname in $(depfile-pkgnames); do
                logger INFO "${pkgname}: Requires ${depname}..."
                logger-push

                incref-by-pkgname "${inverse[@]}" -n "$numrefs" -r -v "$visited $pkgname" "$depname" \
                && updated+=( "$depname" )                                                           \
                && instfile-seek "$depname"                                                          \
                && maxheight=$(max "$maxheight" "$(instfile-get HEIGHT)")                            \
                || isok=0

                logger-pop
                (( isok )) || break
            done

            if (( isok )); then
                # Might as well update the height while we're here, in case it's broken
                instfile-seek "$pkgname"
                instfile-set HEIGHT $((maxheight + 1))
                instfile-save || isok=0
            fi
        fi

        if (( isok )); then
            # Success!
            logger OK "SUCCESS: Updated ${pkgname} reference counter"
            return 0
        fi

        # Rollback the reference counter
        instfile-seek "$pkgname"
        instfile-decref "${inverse[@]}" -n "$numrefs"
        for depname in "${updated[@]}"; do
            logger-push
            decref-by-pkgname "${inverse[@]}" -n "$numrefs" -r -v "$visited $pkgname" "$depname"
            logger-pop
        done
        instfile-save
    fi

    # Failed!
    logger FAIL "FAILED to update ${pkgname} reference counter"
    return 1
}


function decref-by-pkgname() {
    incref-by-pkgname -1 "$@"
}


##############################################################################
# HEIGHT

function incheight-by-pkgname() {
    local OPTIND OPTERR OPTARG opt
    local pkgname minheight
    local recursive=0
    local isok=1

    # Check arguments
    while getopts "r" opt; do
        case "$opt" in
            r)  recursive=1 ;;
        esac
    done
    shift $((OPTIND-1))

    # Optionless arguments
    pkgname=$1
    minheight=$2

    # Increment my height
    logger INFO "${pkgname}: Update height..."
    instfile-seek "$pkgname"
    instfile-set HEIGHT "$minheight"
    instfile-save || isok=0

    if (( isok )); then
        if (( recursive )); then
            local refname
            local refheight

            for refname in $(installed-by-depname "$pkgname"); do
                instfile-seek "$refname"
                refheight=$(instfile-get HEIGHT)

                # Increase the height of the package that depends on this
                # package if it's no higher than this package's height.
                if (( refheight < (minheight+1) )); then
                    logger-push
                    incheight-by-pkgname -r "$refname" "$((minheight+1))"
                    logger-pop
                fi || isok=0

                # ;&
            done
        fi

        # Success!
        if (( isok )); then
            return 0
        fi

        # ;&
    fi

    # Failed!
    return 1
}


##############################################################################
# URL

function url-gethandler() {
    local url=$1
    local handler

    for handler in "${HANDLERS[@]}"; do
        if ! command -v "${handler}-testurl" >& /dev/null; then
            logger WARN "${handler}-testurl missing"
            continue
        fi

        if "${handler}-testurl" "$url"; then
            printf "%s" "$handler"
            return 0
        fi
    done

    logger FAIL "${url}: Cannot determine URL handler"
    return 1
}


function url-pkgname() {
    local url=$1
    local handler
    local isok=1

    handler=$(url-gethandler "$url") || isok=0

    if (( isok )); then
        command -v "${handler}-urlpkg" >&/dev/null || isok=0

        if (( isok )); then
            "${handler}-urlpkg" "$url" || isok=0

            # Success!
            if (( isok )); then
                return 0
            fi
        fi
    fi

    # Failed!
    return 1
}


##############################################################################
# PKG

function pkg-isinstalled() {
    local pkgname=$1

    [[ -n "$pkgname" ]] && [[ -d "${PKGDIR}/${pkgname}" ]]
}


function pkg-gethandler() {
    local pkgname=$1
    local handler

    for handler in "${HANDLERS[@]}"; do
        if ! command -v "${handler}-testpkg" >& /dev/null; then
            logger WARN "${handler}-testpkg missing"
            continue
        fi

        if "${handler}-testpkg" "$pkgname"; then
            # Success!
            printf "%s" "$handler"
            return 0
        fi
    done

    logger FAIL "${pkgname}: Cannot determine package handler"
    return 1
}


function pkg-setup() {
    local pkgname
    local isok=1

    for pkgname in "$@"; do
        local pkgpath="${PKGDIR}/${pkgname}"
        local bashrc="${pkgpath}/etc/bashrc"

        if ! pkg-isinstalled "$pkgname"; then
            logger FAIL "${pkgname}: Not installed, cannot source."
            isok=0
            continue
        fi

        [[ -r "$bashrc" ]] && cat-sh "$bashrc" || isok=0
    done

    (( isok ))
}


##############################################################################
# INSTALLED

function installed() {
    local installed=()
    local pkgpath

    #
    # Any directory in $PKGDIR is assumed to be a package.  Return their names.
    #

    for pkgpath in "${PKGDIR}"/*; do
        if [[ -d "$pkgpath" ]]; then
            local pkgname=${pkgpath##*/}

            installed+=( "$pkgname" )
        fi
    done

    printf "%s" "${installed[*]}"
}


function installed-by-depname() {
    local depname=$1
    local installed=()
    local pkgname
    local line

    #
    # Any installed package matching '^depname|' in etc/dpm-deps is assumed to
    # depend on depname
    #
    for pkgname in $(installed); do
        local depfile="${PKGDIR}/${pkgname}/etc/dpm-deps"

        if [[ -r "$depfile" ]]; then
            while IFS= read -r line; do
                if [[ "$line" == "${depname}|"* ]]; then
                    installed+=( "$pkgname" )
                    break
                fi
            done < "$depfile"
        fi
    done

    printf "%s" "${installed[*]}"
}


##############################################################################
# ACTIVE

function active() {
    local active=()
    local i

    #
    # Return the names of packages in install file with the 'A' flags set,
    # sorted by shortest height to the highest.
    #

    for (( i=0; i < ${#INSTFILE_FLAGS[@]}; i++ )); do
        if [[ "${INSTFILE_FLAGS[i]}" == *A* ]] && (( "${INSTFILE_NUMREF[i]}" > 0 )); then
            active[INSTFILE_HEIGHT[i]]+=" ${INSTFILE_PKGNAME[i]}"
        fi
    done

    printf "%s" "${active[*]#?}"
}


function active-save() {
    local activefile=${1-"${PKGDIR}/.active"}
    local tempfile
    local isok=1

    tempfile=$(mktemp "${PKGDIR}/.active.XXXXXX") || isok=0

    if (( isok )); then
        local pkgname

        for pkgname in $(active); do
            printf "%s\n" "$pkgname"
        done >> "$tempfile" || isok=0

        if (( isok )); then
            mv -f "$tempfile" "$activefile" \
            && chmod =rw "$activefile"      \
            || isok=0

            if (( isok )); then
                return 0
            fi

            # ;&
        fi

        rm -f "$tempfile"
    fi

    return 1
}


##############################################################################
# INSTFILE

function instfile-open() {
    local instfile=${1-"${PKGDIR}/.installed"}
    local pkgname flags numref height rest

    # Initialize
    INSTFILE_PKGNAME=()
    INSTFILE_FLAGS=()
    INSTFILE_NUMREF=()
    INSTFILE_HEIGHT=()
    INSTFILE_REST=()
    LAST_INSTFILE_PKGNAME=""
    LAST_INSTFILE_INDEX=-1

    # Read all columns
    if [[ -r "$instfile" ]]; then
        while IFS=\| read -r pkgname flags numref height rest; do
            INSTFILE_PKGNAME+=( "$pkgname" )
              INSTFILE_FLAGS+=( "$flags"   )
             INSTFILE_NUMREF+=( "$numref"  )
             INSTFILE_HEIGHT+=( "$height"  )
               INSTFILE_REST+=( "$rest"    )
        done < "$instfile"
    fi
}


function instfile-save() {
    local instfile=${1-"${PKGDIR}/.installed"}
    local tempfile
    local isok=1

    tempfile=$(mktemp "${PKGDIR}/.installed.XXXXXX") || isok=0

    if (( isok )); then
        local i

        for (( i=0; i < ${#INSTFILE_PKGNAME[@]}; i++ )); do
            # Skip removed entries
            [[ -z "${INSTFILE_PKGNAME[i]}" ]] && continue
            (( INSTFILE_NUMREF[i] <= 0 )) && continue

            printf "%s|%s|%s|%s|%s\n" "${INSTFILE_PKGNAME[i]}" \
                                      "${INSTFILE_FLAGS[i]}"   \
                                      "${INSTFILE_NUMREF[i]}"  \
                                      "${INSTFILE_HEIGHT[i]}"  \
                                      "${INSTFILE_REST[i]}"
        done >> "$tempfile" || isok=0

        if (( isok )); then
            mv -f "$tempfile" "$instfile" \
            && chmod =rw "$instfile"      \
            || isok=0


            # Success!
            if (( isok )); then
                return 0
            fi

            # ;&
        fi

        rm -f "$tempfile"
    fi

    # Failed!
    logger FAIL "${instfile}: Save failed"
    return 1
}


function instfile-backup() {
    local instfile=${1-"${PKGDIR}/.installed"}
    local bkupfile=${1-"${PKGDIR}/.installed.bkup"}
    local isok=1

    instfile-save "$bkupfile" || isok=0

    if (( isok )); then
        return 0
    fi

    logger FAIL "${instfile}: Backup failed"
    return 1
}


function instfile-restore() {
    local instfile=${1-"${PKGDIR}/.installed"}
    local bkupfile=${1-"${PKGDIR}/.installed.bkup"}

    instfile-open "$bkupfile" || isok=0

    if (( isok )); then
        rm -f "$bkupfile" || isok=0

        if (( isok )); then
            return 0
        fi

        # ;&
    fi

    return 1
}


function instfile-pkgnames() {
    printf "%s" "${INSTFILE_PKGNAME[*]}"
}


function instfile-missing() {
    local missing=()
    local pkgname

    #
    # Return name of any package in the installation record that isn't
    # installed.
    #

    for pkgname in $(instfile-pkgnames); do
        if ! pkg-isinstalled "$pkgname"; then
            missing+=( "$pkgname" )
        fi
    done

    printf "%s" "${missing[*]}"
}


function instfile-direct() {
    local direct=()
    local pkgname

    #
    # Return name of any package in the installation record that has the D
    # flag.
    #

    for pkgname in $(instfile-pkgnames); do
        instfile-seek "$pkgname"

        if [[ "$(instfile-get FLAGS)" == *D* ]]; then
            direct+=( "$pkgname" )
        fi
    done

    printf "%s" "${direct[*]}"
}


function instfile-mvrec() {
    local pkgname1=$1
    local pkgname2=$2

    # Delete pkgname2 if it exists
    instfile-rmrec "$pkgname2"

    # Rename pkgname1 to pkgname2
    instfile-seek "$pkgname1"
    instfile-set PKGNAME "$pkgname2"
}


function instfile-rmrec() {
    local pkgname=$1
    local removed=0

    if instfile-seek "$pkgname"; then
        INSTFILE_PKGNAME[LAST_INSTFILE_INDEX]=""
        INSTFILE_FLAGS[LAST_INSTFILE_INDEX]=""
        INSTFILE_NUMREF[LAST_INSTFILE_INDEX]=0
        INSTFILE_HEIGHT[LAST_INSTFILE_INDEX]=0

        removed=1
    fi

    (( removed ))
}


function instfile-seek() {
    local pkgname=$1
    local found=1

    if [[ "$LAST_INSTFILE_PKGNAME" != "$pkgname" ]]; then
        local i

        # Point past the last record by default
        LAST_INSTFILE_PKGNAME=$pkgname
        LAST_INSTFILE_INDEX=${#INSTFILE_PKGNAME[@]}
        found=0

        for (( i=0; i < ${#INSTFILE_PKGNAME[@]}; i++ )); do
            if [[ "${INSTFILE_PKGNAME[i]}" == "$pkgname" ]]; then
                LAST_INSTFILE_INDEX=$i
                found=1
                break
            fi
        done
    fi

    (( found ))
}


function instfile-get() {
    local name=$1
    local got=1

    case "$name" in
        PKGNAME)  printf "%s" "${INSTFILE_PKGNAME[LAST_INSTFILE_INDEX]}" ;;
          FLAGS)  printf "%s" "${INSTFILE_FLAGS[LAST_INSTFILE_INDEX]}"   ;;
         NUMREF)  printf "%d" "${INSTFILE_NUMREF[LAST_INSTFILE_INDEX]}"  ;;
         HEIGHT)  printf "%d" "${INSTFILE_HEIGHT[LAST_INSTFILE_INDEX]}"  ;;
              *)  logger FAIL "${name}: Invalid install file column"
                  got=0
    esac

    (( got ))
}


function instfile-set() {
    local name=$1
    local value=$2
    local set=1

    # Initialize if inserting a new record
    if [[ -z "${INSTFILE_PKGNAME[LAST_INSTFILE_INDEX]-}" ]]; then
        INSTFILE_PKGNAME[LAST_INSTFILE_INDEX]=$LAST_INSTFILE_PKGNAME
          INSTFILE_FLAGS[LAST_INSTFILE_INDEX]=""
         INSTFILE_NUMREF[LAST_INSTFILE_INDEX]=0
         INSTFILE_HEIGHT[LAST_INSTFILE_INDEX]=0
    fi

    case "$name" in
        PKGNAME)                  LAST_INSTFILE_PKGNAME=$value
                  INSTFILE_PKGNAME[LAST_INSTFILE_INDEX]=$value ;;
          FLAGS)    INSTFILE_FLAGS[LAST_INSTFILE_INDEX]=$value ;;
         NUMREF)   INSTFILE_NUMREF[LAST_INSTFILE_INDEX]=$value ;;
         HEIGHT)   INSTFILE_HEIGHT[LAST_INSTFILE_INDEX]=$value ;;
              *)  logger FAIL "${name}: Invalid instfile column"
                  set=0
    esac

    (( set ))
}


function instfile-setflags() {
    local newflags=$1
    local flags=$(instfile-get FLAGS)
    local i

    # Add the new flags
    for (( i=0; i < ${#newflags}; i++ )); do
        local c=${newflags:i:1}

        if [[ "$flags" != *"$c"* ]]; then
            flags+=$c
        fi
    done

    instfile-set FLAGS "$flags"
}


function instfile-clearflags() {
    local oldflags=$1
    local flags=$(instfile-get FLAGS)
    local i

    # Clear stale flags
    flags=${flags//[${oldflags}]/}

    instfile-set FLAGS "$flags"
}


function instfile-incref() {
    local OPTIND OPTERR OPTARG opt
    local numref=$(instfile-get NUMREF)
    local step=1

    # Check arguments
    while getopts "1n:" opt; do
        case "$opt" in
            1)  step=$((step * -1))     ;;
            n)  step=$((step * OPTARG)) ;;
        esac
    done
    shift $((OPTIND-1))

    instfile-set NUMREF $((numref + step))
}


function instfile-decref() {
    instfile-incref -1 "$@"
}


##############################################################################
# DEPFILE

function depfile-open() {
    local pkgname=$1
    local depfile="${PKGDIR}/${pkgname}/etc/dpm-deps"

    # Initialize
    DEPFILE_PKGNAME=()
    DEPFILE_SOURCES=()
    LAST_DEPFILE=$depfile
    LAST_DEPFILE_PKGNAME=""
    LAST_DEPFILE_SOURCES=()
    LAST_DEPFILE_INDEX=-1

    # Read all columns
    if [[ -r "$depfile" ]]; then
        local depname sources rest

        while IFS=\| read -r depname sources rest; do
            DEPFILE_PKGNAME+=( "$depname" )
            DEPFILE_SOURCES+=( "$sources" )
        done < "$depfile"
    else
        false
    fi
}


function depfile-pkgnames() {
    printf "%s" "${DEPFILE_PKGNAME[*]}"
}


function depfile-seek() {
    local pkgname=$1

    if [[ "$LAST_DEPFILE_PKGNAME" != "$pkgname" ]]; then
        local i

        for (( i=0; i < ${#DEPFILE_PKGNAME[@]}; i++ )); do
            if [[ "${DEPFILE_PKGNAME[i]}" == "$pkgname" ]]; then
                read -d '' -ra LAST_DEPFILE_SOURCES <<<"${DEPFILE_SOURCES[i]}"
                LAST_DEPFILE_PKGNAME=$pkgname
                LAST_DEPFILE_INDEX=$i
                break
            fi

            false
        done
    fi
}


function depfile-get() {
    local name=$1

    case "$name" in
        PKGNAME)  printf "%s" "${DEPFILE_PKGNAME[LAST_DEPFILE_INDEX]}" ;;
        SOURCES)  printf "%s" "${LAST_DEPFILE_SOURCES[*]}"             ;;
              *)  logger FAIL "${name}: Invalid depfile column"
                  false
    esac
}


function depfile-geturl() {
    local i=${1-0}

    if (( i*2 < ${#LAST_DEPFILE_SOURCES[@]} )); then
        printf "%s" "${LAST_DEPFILE_SOURCES[i*2]-}"
        return 0
    fi

    return 1
}


function depfile-getbranch() {
    local i=${1-0}
    local branch

    #
    # The branch is an optional config item.  Its absence, or a star (*) if a
    # placeholder string is required, are both equivalent to a blank branch.
    # 
    # When installing, a blank branch installs the default branch.  When
    # testing, a blank branch matches any branch.
    #

    if (( i*2 < ${#LAST_DEPFILE_SOURCES[@]} )); then
        local branch=${LAST_DEPFILE_SOURCES[i*2+1]-}

        if [[ "$branch" == "*" ]]; then
            branch=""
        fi

        printf "%s" "$branch"
        return 0
    fi

    return 1
}


##############################################################################
# PKGINFO

function pkginfo-seek() {
    local pkgname=$1
    local isok=1

    LAST_PKGNAME=$pkgname
    LAST_PKGHANDLER=$(pkg-gethandler "$pkgname" 2>/dev/null) || isok=0
    instfile-seek "$pkgname" || isok=0

    (( isok ))
}


function pkginfo-get() {
    local name=$1

    case "$name" in
        BRANCH) [[ -n "$LAST_PKGHANDLER" ]] && "${LAST_PKGHANDLER}-getbranch" "$LAST_PKGNAME" ;;
           URL) [[ -n "$LAST_PKGHANDLER" ]] && "${LAST_PKGHANDLER}-geturl" "$LAST_PKGNAME"    ;;
             *) instfile-get "$name" ;;
    esac
}


##############################################################################
# GIT HANDLERS

function git-testdeps() {
    local isok=1

    # Check for git
    if ! command -v git >/dev/null; then
        logger FAIL "Please install 'git'"
        isok=0
    fi

    # Check for awk
    if ! command -v awk >/dev/null; then
        logger FAIL "Please install awk."
        isok=0
    fi

    (( isok ))
}


function git-testurl() {
    local url=$1

    [[ "$url" == *.git ]]
}


function git-testpkg() {
    local pkgname=$1
    local pkgpath="${PKGDIR}/${pkgname}"

    git -C "${pkgpath}" remote get-url origin &> /dev/null
}


function git-urlpkg() {
    local url=$1

    # URLs that don't support <project>.git format can be cloned as <project>/.git
    if [[ "$url" == */.git ]]; then
        url=$(dirname-sh "$url")
    fi

    basename-sh "$url" .git
}


function git-install() {
    local url=$1 pkgname=$2 branch=${3-}
    local args=()

    # Extra arguments to git
    [[ -n "$branch" ]] && args+=( -b "$branch" )

    # Clone
    git -C "$PKGDIR" clone "${args[@]}" "$url" "$pkgname"
}


function git-remove() {
    local pkgname=$1
    local pkgpath="${PKGDIR}/${pkgname}"
    local numchanges
    local isok=1

    # Test the repository for changes
    numchanges=$(git -C "$pkgpath" status --porcelain | wc -l) || isok=0

    if (( isok )) && (( numchanges == 0 )); then
        # Remove the repository
        rm -rf "$pkgpath" || isok=0
    elif (( isok )); then
        printf "%s\n" "${pkgname}: Has uncommitted changes, will not remove." 1>&2
        isok=0
    fi

    (( isok ))
}


function git-update() {
    local pkgname=$1

    # Clone
    git -C "${PKGDIR}/${pkgname}" pull
}


function git-geturl() {
    local pkgname=$1
    local pkgpath="${PKGDIR}/${pkgname}"

    git -C "$pkgpath" remote -v | awk '/\(fetch\)$/ { print $2 }'
}


function git-getbranch() {
    local pkgname=$1
    local pkgpath="${PKGDIR}/${pkgname}"

    git -C "$pkgpath" branch 2>/dev/null | awk '/^[*]/ { print $2 }'
}


##############################################################################
# PIP HANDLERS

# Print the pip command
function pip--command() {
    command -v pip3 || command -v pip
}


# Execute a pip command
function pip--exec() {
    "$(pip--command)" "$@"
}


# Convert dpmpkg to pippkg
function pip--pippkg() {
    local dpmpkg=$1
    local url=$(pip-geturl "$dpmpkg")

    pip-urlpkg "$url"
}


# True if a pippkg is installed
function pip--installed() {
    local pippkg=$1

    pip--exec show "$pippkg" &>/dev/null
}


# True if pip dependencies are installed, false otherwise.
function pip-testdeps() {
    local isok=1

    # Check for pip
    if ! pip--command >/dev/null; then
        logger FAIL "Please install 'pip'"
        isok=0
    fi

    (( isok ))
}


# Test whether the url is to a pip package
function pip-testurl() {
    local url=$1

    [[ "$url" == *.pip ]]
}


# Test whether a dpmpkg is a pip package
function pip-testpkg() {
    local dpmpkg=$1
    local pkgpath="${PKGDIR}/${dpmpkg}"

    [[ -f "${pkgpath}/.dpm/pip" ]]
}


# Print default dpmpkg of a pipurl
function pip-urlpkg() {
    local url=$1

    basename-sh "$url" .pip
}


# Install the pippkg given its pipurl
function pip-install() {
    local url=$1 dpmpkg=$2 version=${3-}
    local pkgpath="${PKGDIR}/${dpmpkg}"
    local pippkg=$(pip-urlpkg "$url")

    # Suffix version
    [[ -n "$version" ]] && pippkg="${pippkg}==${version}"

    # Install
    ! pip--installed "$pippkg"      \
    && pip--exec install "$pippkg"

    # Create the meta package
    pip--installed "$pippkg"        \
    && mkdir -p "$pkgpath/.dpm"     \
    && printf "%s\n%s\n" "$url" "$version" > "$pkgpath/.dpm/pip"
}


function pip-remove() {
    local dpmpkg=$1
    local pkgpath="${PKGDIR}/${dpmpkg}"
    local pippkg=$(pip--pippkg "$dpmpkg")
    local isok=1

    # Uninstall
    pip--installed "$pippkg"        \
    && pip--exec uninstall -y "$pippkg"

    # Remove the repository
    ! pip--installed "$pippkg"      \
    && rm -rf "$pkgpath" || isok=0

    (( isok ))
}


function pip-update() {
    local dpmpkg=$1
    local pippkg=$(pip-urlpkg "$url")

    logger INFO "${dpmpkg}: Pip package, please use pip to update."
}


function pip-geturl() {
    local dpmpkg=$1
    local pkgpath="${PKGDIR}/${dpmpkg}"
    local lines=()

    IFS=$'\n' read -d '' -ra lines < "${pkgpath}/.dpm/pip"

    printf "%s" "${lines[0]}"
}


function pip-getbranch() {
    local dpmpkg=$1
    local pkgpath="${PKGDIR}/${dpmpkg}"
    local pippkg=$(pip--pippkg "$dpmpkg")
    local lines=()
    local version
    local line

    # Get the version that's supposed to be installed
    IFS=$'\n' read -d '' -ra lines < "${pkgpath}/.dpm/pip"
    version=${lines[1]}

    # Get the version that's actually installed
    while IFS= read -r line; do
        if [[ "$line" == "Version: "* ]]; then
            version=${line##* }
            break
        fi
    done < <(pip--exec show "$pippkg" 2>/dev/null)

    printf "%s" "$version"
}


##############################################################################
# LOCAL HANDLERS

function local-testdeps() {
    local isok=1

    (( isok ))
}


function local-testurl() {
    local url=$1

    [[ "$url" == *.dpmlocal ]]
}


function local-testpkg() {
    local pkgname=$1
    local pkgpath="${PKGDIR}/${pkgname}"

    [[ -e "${pkgpath}/.dpmlocal" ]]
}


function local-urlpkg() {
    local url=$1

    # URL may be in the format <project>.dpmlocal or <project>/.dpmlocal
    if [[ "$url" == */.dpmlocal ]]; then
        url=$(dirname-sh "$url")
    fi

    basename-sh "$url" .dpmlocal
}


function local-install() {
    local url=$1 pkgname=$2 branch=${3-}

    logger INFO "${pkgname}: Local package, nothing to install."
}


function local-remove() {
    local pkgname=$1
    local pkgpath="${PKGDIR}/${pkgname}"
    local isok=1

    # Remove the repository
    rm -rf "$pkgpath" || isok=0

    (( isok ))
}


function local-update() {
    local pkgname=$1

    logger INFO "${pkgname}: Local package, nothing to update."
}


function local-geturl() {
    local pkgname=$1
    local pkgpath="${PKGDIR}/${pkgname}"

    printf "%s" "${pkgpath}/.dpmlocal"
}


function local-getbranch() {
    local pkgname=$1
    local pkgpath="${PKGDIR}/${pkgname}"

    printf "%s" "-"
}


##############################################################################
# GENERIC UTILITIES

function egetopt() {
    local shortopts=$1 && shift
    local longopts=$1 && shift

    #
    # Use GNU "getopt" if available, otherwise fall back to "getopts" built-in.
    # GNU gives us long options but it's not always available.
    #

    if command -v getopt >/dev/null && getopt -T >/dev/null; (( $? == 4 )); then
        getopt -o "$shortopts" --long "$longopts" -- "$@"
    else
        local OPTARG OPTIND OPTERR opt
        local output=()
        local isok=1

        while getopts "$shortopts" opt; do
            output+=( "-${opt}" )
            [[ "$shortopts" == *"${opt}:"* ]] && output+=( "$OPTARG" )
            [[ "$shortopts" != *"${opt}"* ]] && isok=0
        done
        shift $((OPTIND-1))

        printf " %q" "${output[@]}" -- "$@"
        printf "\n"

        (( isok ))
    fi
}


function logger() {
    local level=$1 && shift
    local line

    # Center the level to 4 characters
    case "${#level}" in
        1)  printf -v level "  %s " "${level}" ;;
        2)  printf -v level " %s " "${level}"  ;;
        3)  printf -v level " %s" "${level}"   ;;
        *)  printf -v level "%s" "${level::4}" ;;
    esac

    # Print arguments or stdin.
    while IFS= read -r line; do
        printf -v line "%*s[%4s] %s\n" "$LOGGER_INDENT" "" "$level" "$line"

        case "$level" in
            " OK ")  colorize green  "$line" 1      ;;
            "WARN")  colorize yellow "$line" 2 1>&2 ;;
            "FAIL")  colorize red    "$line" 2 1>&2 ;;
            *)       printf "%s" "$line" ;;
        esac
    done < <( (( $# )) && printf "%s\n" "$@" || cat-sh )
}


function logger-push() {
    local count=${1-1}

    (( LOGGER_INDENT += 2 * count )) || :
}


function logger-pop() {
    local count=${1-1}

    (( LOGGER_INDENT -= 2 * count )) || :
}


function colorize() {
    local color=$1
    local text=$2
    local fd=${3-}
    local begin=""
    local end=""

    if [[ -z "$fd" || -t "$fd" ]]; then
        end=$'\e[0m'

        case "$color" in
            red)    begin=$'\e[1;31m' ;;
            green)  begin=$'\e[1;32m' ;;
            yellow) begin=$'\e[1;33m' ;;
        esac
    fi

    printf "%s" "${begin}${text}${end}"
}


function max() {
    local value=$1

    if (( "$2" > "$1" )); then
        value=$2
    fi

    printf "%s" "$value"
}

function dirname-sh() {
    local fullname=$1

    printf "%s\n" "${fullname%/*}"
}

function basename-sh() {
    local fullname=$1
    local suffix=$2
    local basename

    basename=${fullname##*/}
    basename=${basename%${suffix}}

    printf "%s\n" "$basename"
}

function cat-sh() {
    local file=$1

    if [[ -z "$file" ]]; then
        file=/dev/stdin
    fi

    printf "%s\n" "$(< "$file")"
}


##############################################################################
# ENTRY POINT

main "$@"
